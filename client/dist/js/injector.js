!function(e){function n(c){if(t[c])return t[c].exports;var i=t[c]={i:c,l:!1,exports:{}};return e[c].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var t={};n.m=e,n.c=t,n.i=function(e){return e},n.d=function(e,t,c){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:c})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s="./node_modules/@silverstripe/react-injector/dist/injector.js")}({"./node_modules/@silverstripe/react-injector/dist/injector.js":function(module,exports){!function(e){function n(c){if(t[c])return t[c].exports;var i=t[c]={i:c,l:!1,exports:{}};return e[c].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var t={};n.m=e,n.c=t,n.d=function(e,t,c){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:c})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var c=Object.create(null);if(n.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(c,i,function(n){return e[n]}.bind(null,i));return c},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=7)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(9);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLENBQStCO0FBQzFELENBQUMsTUFBTSxFQUVOIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(12)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUscUNBTzFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLEVBQTRCO0FBQ3ZEIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (true) {\n  root = module;\n} else {}\n\nvar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(root);\n/* harmony default export */ __webpack_exports__[\"a\"] = (result);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3), __webpack_require__(11)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanM/NmMyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ3FDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxVQUFVLElBQTZCO0FBQ3hDO0FBQ0EsQ0FBQyxNQUFNLEVBRU47O0FBRUQsYUFBYSxvRUFBUTtBQUNOLCtEQUFNLEVBQUMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBwb255ZmlsbCBmcm9tICcuL3BvbnlmaWxsLmpzJztcblxudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9IHBvbnlmaWxsKHJvb3QpO1xuZXhwb3J0IGRlZmF1bHQgcmVzdWx0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("\n/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function(edges) {\n  return toposort(uniqueNodes(edges), edges)\n}\n\nmodule.exports.array = toposort\n\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length\n    , sorted = new Array(cursor)\n    , visited = {}\n    , i = cursor\n    // Better data structures make algorithm much faster.\n    , outgoingEdges = makeOutgoingEdges(edges)\n    , nodesHash = makeNodesHash(nodes)\n\n  // check for unknown nodes\n  edges.forEach(function(edge) {\n    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n      throw new Error('Unknown node. There is an unknown node in the supplied edges.')\n    }\n  })\n\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, new Set())\n  }\n\n  return sorted\n\n  function visit(node, i, predecessors) {\n    if(predecessors.has(node)) {\n      var nodeRep\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node)\n      } catch(e) {\n        nodeRep = \"\"\n      }\n      throw new Error('Cyclic dependency' + nodeRep)\n    }\n\n    if (!nodesHash.has(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))\n    }\n\n    if (visited[i]) return;\n    visited[i] = true\n\n    var outgoing = outgoingEdges.get(node) || new Set()\n    outgoing = Array.from(outgoing)\n\n    if (i = outgoing.length) {\n      predecessors.add(node)\n      do {\n        var child = outgoing[--i]\n        visit(child, nodesHash.get(child), predecessors)\n      } while (i)\n      predecessors.delete(node)\n    }\n\n    sorted[--cursor] = node\n  }\n}\n\nfunction uniqueNodes(arr){\n  var res = new Set()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    res.add(edge[0])\n    res.add(edge[1])\n  }\n  return Array.from(res)\n}\n\nfunction makeOutgoingEdges(arr){\n  var edges = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    if (!edges.has(edge[0])) edges.set(edge[0], new Set())\n    if (!edges.has(edge[1])) edges.set(edge[1], new Set())\n    edges.get(edge[0]).add(edge[1])\n  }\n  return edges\n}\n\nfunction makeNodesHash(arr){\n  var res = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res.set(arr[i], i)\n  }\n  return res\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQvaW5kZXguanM/YWY5YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVG9wb2xvZ2ljYWwgc29ydGluZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGVkZ2VzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlZGdlcykge1xuICByZXR1cm4gdG9wb3NvcnQodW5pcXVlTm9kZXMoZWRnZXMpLCBlZGdlcylcbn1cblxubW9kdWxlLmV4cG9ydHMuYXJyYXkgPSB0b3Bvc29ydFxuXG5mdW5jdGlvbiB0b3Bvc29ydChub2RlcywgZWRnZXMpIHtcbiAgdmFyIGN1cnNvciA9IG5vZGVzLmxlbmd0aFxuICAgICwgc29ydGVkID0gbmV3IEFycmF5KGN1cnNvcilcbiAgICAsIHZpc2l0ZWQgPSB7fVxuICAgICwgaSA9IGN1cnNvclxuICAgIC8vIEJldHRlciBkYXRhIHN0cnVjdHVyZXMgbWFrZSBhbGdvcml0aG0gbXVjaCBmYXN0ZXIuXG4gICAgLCBvdXRnb2luZ0VkZ2VzID0gbWFrZU91dGdvaW5nRWRnZXMoZWRnZXMpXG4gICAgLCBub2Rlc0hhc2ggPSBtYWtlTm9kZXNIYXNoKG5vZGVzKVxuXG4gIC8vIGNoZWNrIGZvciB1bmtub3duIG5vZGVzXG4gIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgIGlmICghbm9kZXNIYXNoLmhhcyhlZGdlWzBdKSB8fCAhbm9kZXNIYXNoLmhhcyhlZGdlWzFdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUuIFRoZXJlIGlzIGFuIHVua25vd24gbm9kZSBpbiB0aGUgc3VwcGxpZWQgZWRnZXMuJylcbiAgICB9XG4gIH0pXG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICghdmlzaXRlZFtpXSkgdmlzaXQobm9kZXNbaV0sIGksIG5ldyBTZXQoKSlcbiAgfVxuXG4gIHJldHVybiBzb3J0ZWRcblxuICBmdW5jdGlvbiB2aXNpdChub2RlLCBpLCBwcmVkZWNlc3NvcnMpIHtcbiAgICBpZihwcmVkZWNlc3NvcnMuaGFzKG5vZGUpKSB7XG4gICAgICB2YXIgbm9kZVJlcFxuICAgICAgdHJ5IHtcbiAgICAgICAgbm9kZVJlcCA9IFwiLCBub2RlIHdhczpcIiArIEpTT04uc3RyaW5naWZ5KG5vZGUpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbm9kZVJlcCA9IFwiXCJcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGljIGRlcGVuZGVuY3knICsgbm9kZVJlcClcbiAgICB9XG5cbiAgICBpZiAoIW5vZGVzSGFzaC5oYXMobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5rbm93biBub2RlLiBNYWtlIHN1cmUgdG8gcHJvdmlkZWQgYWxsIGludm9sdmVkIG5vZGVzLiBVbmtub3duIG5vZGU6ICcrSlNPTi5zdHJpbmdpZnkobm9kZSkpXG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWRbaV0pIHJldHVybjtcbiAgICB2aXNpdGVkW2ldID0gdHJ1ZVxuXG4gICAgdmFyIG91dGdvaW5nID0gb3V0Z29pbmdFZGdlcy5nZXQobm9kZSkgfHwgbmV3IFNldCgpXG4gICAgb3V0Z29pbmcgPSBBcnJheS5mcm9tKG91dGdvaW5nKVxuXG4gICAgaWYgKGkgPSBvdXRnb2luZy5sZW5ndGgpIHtcbiAgICAgIHByZWRlY2Vzc29ycy5hZGQobm9kZSlcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb3V0Z29pbmdbLS1pXVxuICAgICAgICB2aXNpdChjaGlsZCwgbm9kZXNIYXNoLmdldChjaGlsZCksIHByZWRlY2Vzc29ycylcbiAgICAgIH0gd2hpbGUgKGkpXG4gICAgICBwcmVkZWNlc3NvcnMuZGVsZXRlKG5vZGUpXG4gICAgfVxuXG4gICAgc29ydGVkWy0tY3Vyc29yXSA9IG5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmlxdWVOb2RlcyhhcnIpe1xuICB2YXIgcmVzID0gbmV3IFNldCgpXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGFycltpXVxuICAgIHJlcy5hZGQoZWRnZVswXSlcbiAgICByZXMuYWRkKGVkZ2VbMV0pXG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzKVxufVxuXG5mdW5jdGlvbiBtYWtlT3V0Z29pbmdFZGdlcyhhcnIpe1xuICB2YXIgZWRnZXMgPSBuZXcgTWFwKClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlZGdlID0gYXJyW2ldXG4gICAgaWYgKCFlZGdlcy5oYXMoZWRnZVswXSkpIGVkZ2VzLnNldChlZGdlWzBdLCBuZXcgU2V0KCkpXG4gICAgaWYgKCFlZGdlcy5oYXMoZWRnZVsxXSkpIGVkZ2VzLnNldChlZGdlWzFdLCBuZXcgU2V0KCkpXG4gICAgZWRnZXMuZ2V0KGVkZ2VbMF0pLmFkZChlZGdlWzFdKVxuICB9XG4gIHJldHVybiBlZGdlc1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZXNIYXNoKGFycil7XG4gIHZhciByZXMgPSBuZXcgTWFwKClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlcy5zZXQoYXJyW2ldLCBpKVxuICB9XG4gIHJldHVybiByZXNcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return symbolObservablePonyfill; });\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanM/NDhiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcz80ZDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUssS0FBNkI7QUFDbEM7QUFDQTtBQUNBLEVBQUUsVUFBVSxJQUE0RTtBQUN4RjtBQUNBLEVBQUUsaUNBQXFCLEVBQUUsbUNBQUU7QUFDM0I7QUFDQSxHQUFHO0FBQUEsb0dBQUM7QUFDSixFQUFFLE1BQU0sRUFFTjtBQUNGLENBQUMiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval("// Injector.js is exposed on the global / window object so apps using it can share state\n__webpack_require__(8);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBQSxtQkFBTyxDQUFDLENBQUQsQ0FBUCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5qZWN0b3IuanMgaXMgZXhwb3NlZCBvbiB0aGUgZ2xvYmFsIC8gd2luZG93IG9iamVjdCBzbyBhcHBzIHVzaW5nIGl0IGNhbiBzaGFyZSBzdGF0ZVxucmVxdWlyZSgnZXhwb3NlLWxvYWRlcj9JbmplY3RvciEuL0luamVjdG9yJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["Injector"] = __webpack_require__(14);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSW5qZWN0b3IuanMtZXhwb3NlZD9jOTBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9GQUFzQyxtQkFBTyxDQUFDLEVBQWdHLEUiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiSW5qZWN0b3JcIl0gPSByZXF1aXJlKFwiLSEvVXNlcnMvZ2hlcm1hbi9jb2RlL21vZHVsZXMvaW5qZWN0b3IuanMvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9JbmplY3Rvci5qc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){"use strict";eval('/** @license React v16.8.3\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar k=__webpack_require__(10),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.concurrent_mode"):60111,y=n?Symbol.for("react.forward_ref"):60112,z=n?Symbol.for("react.suspense"):60113,aa=n?Symbol.for("react.memo"):\n60115,ba=n?Symbol.for("react.lazy"):60116,A="function"===typeof Symbol&&Symbol.iterator;function ca(a,b,d,c,e,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[d,c,e,g,h,f],m=0;a=Error(b.replace(/%s/g,function(){return l[m++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}\nfunction B(a){for(var b=arguments.length-1,d="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)d+="&args[]="+encodeURIComponent(arguments[c+1]);ca(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",d)}var C={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},D={};\nfunction E(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}E.prototype.isReactComponent={};E.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?B("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}var H=G.prototype=new F;\nH.constructor=G;k(H,E.prototype);H.isPureReactComponent=!0;var I={current:null},J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,d){var c=void 0,e={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];e.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:h,props:e,_owner:J.current}}\nfunction da(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return{result:a,keyPrefix:b,func:d,context:c,count:0}}\nfunction R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}\nfunction S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){e=a[h];var f=b+T(e,h);g+=S(e,f,d,c)}else if(null===a||"object"!==typeof a?f=null:(f=A&&a[A]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),h=\n0;!(e=a.next()).done;)e=e.value,f=b+T(e,h++),g+=S(e,f,d,c);else"object"===e&&(d=""+a,B("31","[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,""));return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ea(a,b){a.func.call(a.context,b,a.count++)}\nfunction fa(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=da(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a))}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,fa,b);R(b)}function W(){var a=I.current;null===a?B("307"):void 0;return a}\nvar X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,ea,b);R(b)},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){N(a)?void 0:B("143");return a}},createRef:function(){return{current:null}},Component:E,PureComponent:G,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,\n_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:y,render:a}},lazy:function(a){return{$$typeof:ba,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:aa,type:a,compare:void 0===b?null:b}},useCallback:function(a,b){return W().useCallback(a,b)},useContext:function(a,b){return W().useContext(a,b)},useEffect:function(a,b){return W().useEffect(a,b)},useImperativeHandle:function(a,\nb,d){return W().useImperativeHandle(a,b,d)},useDebugValue:function(){},useLayoutEffect:function(a,b){return W().useLayoutEffect(a,b)},useMemo:function(a,b){return W().useMemo(a,b)},useReducer:function(a,b,d){return W().useReducer(a,b,d)},useRef:function(a){return W().useRef(a)},useState:function(a){return W().useState(a)},Fragment:r,StrictMode:t,Suspense:z,createElement:M,cloneElement:function(a,b,d){null===a||void 0===a?B("267",a):void 0;var c=void 0,e=k({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=\nb){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];e.children=l}return{$$typeof:p,type:a.type,key:g,ref:h,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.8.3",\nunstable_ConcurrentMode:x,unstable_Profiler:u,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:I,ReactCurrentOwner:J,assign:k}},Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlMjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYSxNQUFNLG1CQUFPLENBQUMsRUFBZTtBQUMxQyx3RkFBd0YsNkJBQTZCLE9BQU8sU0FBUyxtREFBbUQsb0dBQW9HLEtBQUssd0JBQXdCLG1DQUFtQyxjQUFjLEdBQUcsNkJBQTZCLGdCQUFnQjtBQUMxWixjQUFjLDhGQUE4RixJQUFJLHFEQUFxRCxtQ0FBbUMsNkhBQTZILE9BQU8scUJBQXFCLFNBQVMsZ0NBQWdDLGlDQUFpQyw4QkFBOEI7QUFDemMsa0JBQWtCLGFBQWEsZUFBZSxZQUFZLGtCQUFrQixnQ0FBZ0MsbUNBQW1DLG1FQUFtRSxtREFBbUQsb0NBQW9DLHVEQUF1RCxjQUFjLHdCQUF3QixrQkFBa0IsYUFBYSxlQUFlLFlBQVksa0JBQWtCO0FBQ2xkLGdCQUFnQixpQkFBaUIsMEJBQTBCLE9BQU8sYUFBYSxJQUFJLGFBQWEsc0NBQXNDO0FBQ3RJLGtCQUFrQixpQkFBaUIsZUFBZSw0SEFBNEgseUJBQXlCLHNCQUFzQixhQUFhLHVCQUF1QixJQUFJLHdCQUF3QixhQUFhLDRFQUE0RSxPQUFPO0FBQzdYLGlCQUFpQixPQUFPLHNFQUFzRSxjQUFjLG9EQUFvRCxtQkFBbUIsT0FBTyxtQkFBbUIsNkNBQTZDLFlBQVksRUFBRSxrQkFBa0Isb0JBQW9CLGFBQWEsY0FBYyxXQUFXLGNBQWMsU0FBUyxZQUFZLFVBQVUsU0FBUyxPQUFPO0FBQ2paLGNBQWMsY0FBYyxpQkFBaUIsWUFBWSxlQUFlLFVBQVU7QUFDbEYsb0JBQW9CLGVBQWUseUNBQXlDLFNBQVMsaUJBQWlCLGVBQWUsaUNBQWlDLE1BQU0saUNBQWlDLG9CQUFvQix5Q0FBeUMsSUFBSSxtQkFBbUIsZ0NBQWdDLFdBQVcsS0FBSyxPQUFPLGVBQWUsY0FBYztBQUNyVyxFQUFFLG1CQUFtQixzQ0FBc0MsMEVBQTBFLDhCQUE4QixTQUFTLFNBQVMsa0JBQWtCLDZCQUE2QixnQkFBZ0IsOEVBQThFLGlCQUFpQjtBQUNuVixtQkFBbUIsNkJBQTZCLHFDQUFxQyxxQ0FBcUMsU0FBUyx5R0FBeUcsc0JBQXNCLFNBQVMseUNBQXlDLGFBQWEsVUFBVSxLQUFLLGFBQWEsZ0JBQWdCLHlCQUF5QjtBQUN0WSxPQUFPLFVBQVUsb0JBQW9CLG9CQUFvQixTQUFTLGdCQUFnQixTQUFTLHlCQUF5QixvQkFBb0IsbUJBQW1CLFVBQVUsS0FBSyxtQkFBbUIsc0JBQXNCLFlBQVksT0FBTyxxQkFBcUIsU0FBUyx1QkFBdUIsU0FBUyxFQUFFLFNBQVMsa0JBQWtCLHFCQUFxQixVQUFVLHNCQUFzQixPQUFPLGNBQWMseURBQXlELHFCQUFxQixHQUFHO0FBQzVkLDZFQUE2RSxZQUFZLHVCQUF1QixvQkFBb0Isd0JBQXdCLE9BQU8scUJBQXFCLGtCQUFrQixPQUFPLDZDQUE2QyxvQkFBb0IsT0FBTyw4Q0FBOEMsMkJBQTJCLDRCQUE0QiwwQkFBMEIsMkJBQTJCLHlCQUF5QiwwQkFBMEI7QUFDdGUsS0FBSyxzQ0FBc0MsMkJBQTJCLCtCQUErQixnQ0FBZ0MsdUJBQXVCLHdCQUF3Qiw0QkFBNEIsNkJBQTZCLG9CQUFvQixxQkFBcUIsc0JBQXNCLHVCQUF1QixpRkFBaUYsdUNBQXVDLG1CQUFtQixxQ0FBcUM7QUFDbmYsR0FBRyxzQ0FBc0MsNkJBQTZCLGFBQWEscURBQXFELHlGQUF5RixxQkFBcUIsc0JBQXNCLGFBQWEsV0FBVyxZQUFZLElBQUksd0JBQXdCLGFBQWEsT0FBTyxxREFBcUQsMkJBQTJCLHFCQUFxQixTQUFTLFNBQVM7QUFDdmQsa0dBQWtHLHVEQUF1RCxJQUFJLFVBQVUsV0FBVyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjNcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBrPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcixwPW4/U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMscT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYscj1uP1N5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx0PW4/U3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpOjYwMTA4LHU9bj9TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik6NjAxMTQsdj1uP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTo2MDEwOSx3PW4/U3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik6NjAxMTAseD1uP1N5bWJvbC5mb3IoXCJyZWFjdC5jb25jdXJyZW50X21vZGVcIik6NjAxMTEseT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMix6PW4/U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpOjYwMTEzLGFhPW4/U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik6XG42MDExNSxiYT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpOjYwMTE2LEE9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIGNhKGEsYixkLGMsZSxnLGgsZil7aWYoIWEpe2E9dm9pZCAwO2lmKHZvaWQgMD09PWIpYT1FcnJvcihcIk1pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2Vsc2V7dmFyIGw9W2QsYyxlLGcsaCxmXSxtPTA7YT1FcnJvcihiLnJlcGxhY2UoLyVzL2csZnVuY3Rpb24oKXtyZXR1cm4gbFttKytdfSkpO2EubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIn1hLmZyYW1lc1RvUG9wPTE7dGhyb3cgYTt9fVxuZnVuY3Rpb24gQihhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGQ9XCJodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD1cIithLGM9MDtjPGI7YysrKWQrPVwiJmFyZ3NbXT1cIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2MrMV0pO2NhKCExLFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0ICVzIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4gXCIsZCl9dmFyIEM9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEQ9e307XG5mdW5jdGlvbiBFKGEsYixkKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUQ7dGhpcy51cGRhdGVyPWR8fEN9RS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtFLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/QihcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0UucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O2Z1bmN0aW9uIEYoKXt9Ri5wcm90b3R5cGU9RS5wcm90b3R5cGU7ZnVuY3Rpb24gRyhhLGIsZCl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1EO3RoaXMudXBkYXRlcj1kfHxDfXZhciBIPUcucHJvdG90eXBlPW5ldyBGO1xuSC5jb25zdHJ1Y3Rvcj1HO2soSCxFLnByb3RvdHlwZSk7SC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgST17Y3VycmVudDpudWxsfSxKPXtjdXJyZW50Om51bGx9LEs9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxMPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBNKGEsYixkKXt2YXIgYz12b2lkIDAsZT17fSxnPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilLLmNhbGwoYixjKSYmIUwuaGFzT3duUHJvcGVydHkoYykmJihlW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZillLmNoaWxkcmVuPWQ7ZWxzZSBpZigxPGYpe2Zvcih2YXIgbD1BcnJheShmKSxtPTA7bTxmO20rKylsW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49bH1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZVtjXSYmKGVbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnAsdHlwZTphLGtleTpnLHJlZjpoLHByb3BzOmUsX293bmVyOkouY3VycmVudH19XG5mdW5jdGlvbiBkYShhLGIpe3JldHVybnskJHR5cGVvZjpwLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn19ZnVuY3Rpb24gTihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiPVwiOlwiPTBcIixcIjpcIjpcIj0yXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBPPS9cXC8rL2csUD1bXTtmdW5jdGlvbiBRKGEsYixkLGMpe2lmKFAubGVuZ3RoKXt2YXIgZT1QLnBvcCgpO2UucmVzdWx0PWE7ZS5rZXlQcmVmaXg9YjtlLmZ1bmM9ZDtlLmNvbnRleHQ9YztlLmNvdW50PTA7cmV0dXJuIGV9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZCxjb250ZXh0OmMsY291bnQ6MH19XG5mdW5jdGlvbiBSKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+UC5sZW5ndGgmJlAucHVzaChhKX1cbmZ1bmN0aW9uIFMoYSxiLGQsYyl7dmFyIGU9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWV8fFwiYm9vbGVhblwiPT09ZSlhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChlKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHA6Y2FzZSBxOmc9ITB9fWlmKGcpcmV0dXJuIGQoYyxhLFwiXCI9PT1iP1wiLlwiK1QoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGg9MDtoPGEubGVuZ3RoO2grKyl7ZT1hW2hdO3ZhciBmPWIrVChlLGgpO2crPVMoZSxmLGQsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhP2Y9bnVsbDooZj1BJiZhW0FdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGg9XG4wOyEoZT1hLm5leHQoKSkuZG9uZTspZT1lLnZhbHVlLGY9YitUKGUsaCsrKSxnKz1TKGUsZixkLGMpO2Vsc2VcIm9iamVjdFwiPT09ZSYmKGQ9XCJcIithLEIoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1kP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmQsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFUoYSxiLGQpe3JldHVybiBudWxsPT1hPzA6UyhhLFwiXCIsYixkKX1mdW5jdGlvbiBUKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBlYShhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBmYShhLGIsZCl7dmFyIGM9YS5yZXN1bHQsZT1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9WKGEsYyxkLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk6bnVsbCE9YSYmKE4oYSkmJihhPWRhKGEsZSsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTyxcIiQmL1wiKStcIi9cIikrZCkpLGMucHVzaChhKSl9ZnVuY3Rpb24gVihhLGIsZCxjLGUpe3ZhciBnPVwiXCI7bnVsbCE9ZCYmKGc9KFwiXCIrZCkucmVwbGFjZShPLFwiJCYvXCIpK1wiL1wiKTtiPVEoYixnLGMsZSk7VShhLGZhLGIpO1IoYil9ZnVuY3Rpb24gVygpe3ZhciBhPUkuY3VycmVudDtudWxsPT09YT9CKFwiMzA3XCIpOnZvaWQgMDtyZXR1cm4gYX1cbnZhciBYPXtDaGlsZHJlbjp7bWFwOmZ1bmN0aW9uKGEsYixkKXtpZihudWxsPT1hKXJldHVybiBhO3ZhciBjPVtdO1YoYSxjLG51bGwsYixkKTtyZXR1cm4gY30sZm9yRWFjaDpmdW5jdGlvbihhLGIsZCl7aWYobnVsbD09YSlyZXR1cm4gYTtiPVEobnVsbCxudWxsLGIsZCk7VShhLGVhLGIpO1IoYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBVKGEsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VihhLGIsbnVsbCxmdW5jdGlvbihhKXtyZXR1cm4gYX0pO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe04oYSk/dm9pZCAwOkIoXCIxNDNcIik7cmV0dXJuIGF9fSxjcmVhdGVSZWY6ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpudWxsfX0sQ29tcG9uZW50OkUsUHVyZUNvbXBvbmVudDpHLGNyZWF0ZUNvbnRleHQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjp3LF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLFxuX2N1cnJlbnRWYWx1ZTphLF9jdXJyZW50VmFsdWUyOmEsX3RocmVhZENvdW50OjAsUHJvdmlkZXI6bnVsbCxDb25zdW1lcjpudWxsfTthLlByb3ZpZGVyPXskJHR5cGVvZjp2LF9jb250ZXh0OmF9O3JldHVybiBhLkNvbnN1bWVyPWF9LGZvcndhcmRSZWY6ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOnkscmVuZGVyOmF9fSxsYXp5OmZ1bmN0aW9uKGEpe3JldHVybnskJHR5cGVvZjpiYSxfY3RvcjphLF9zdGF0dXM6LTEsX3Jlc3VsdDpudWxsfX0sbWVtbzpmdW5jdGlvbihhLGIpe3JldHVybnskJHR5cGVvZjphYSx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19LHVzZUNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFcoKS51c2VDYWxsYmFjayhhLGIpfSx1c2VDb250ZXh0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFcoKS51c2VDb250ZXh0KGEsYil9LHVzZUVmZmVjdDpmdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlRWZmZWN0KGEsYil9LHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxcbmIsZCl7cmV0dXJuIFcoKS51c2VJbXBlcmF0aXZlSGFuZGxlKGEsYixkKX0sdXNlRGVidWdWYWx1ZTpmdW5jdGlvbigpe30sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFcoKS51c2VMYXlvdXRFZmZlY3QoYSxiKX0sdXNlTWVtbzpmdW5jdGlvbihhLGIpe3JldHVybiBXKCkudXNlTWVtbyhhLGIpfSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gVygpLnVzZVJlZHVjZXIoYSxiLGQpfSx1c2VSZWY6ZnVuY3Rpb24oYSl7cmV0dXJuIFcoKS51c2VSZWYoYSl9LHVzZVN0YXRlOmZ1bmN0aW9uKGEpe3JldHVybiBXKCkudXNlU3RhdGUoYSl9LEZyYWdtZW50OnIsU3RyaWN0TW9kZTp0LFN1c3BlbnNlOnosY3JlYXRlRWxlbWVudDpNLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZCl7bnVsbD09PWF8fHZvaWQgMD09PWE/QihcIjI2N1wiLGEpOnZvaWQgMDt2YXIgYz12b2lkIDAsZT1rKHt9LGEucHJvcHMpLGc9YS5rZXksaD1hLnJlZixmPWEuX293bmVyO2lmKG51bGwhPVxuYil7dm9pZCAwIT09Yi5yZWYmJihoPWIucmVmLGY9Si5jdXJyZW50KTt2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSk7dmFyIGw9dm9pZCAwO2EudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyYmKGw9YS50eXBlLmRlZmF1bHRQcm9wcyk7Zm9yKGMgaW4gYilLLmNhbGwoYixjKSYmIUwuaGFzT3duUHJvcGVydHkoYykmJihlW2NdPXZvaWQgMD09PWJbY10mJnZvaWQgMCE9PWw/bFtjXTpiW2NdKX1jPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09YyllLmNoaWxkcmVuPWQ7ZWxzZSBpZigxPGMpe2w9QXJyYXkoYyk7Zm9yKHZhciBtPTA7bTxjO20rKylsW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49bH1yZXR1cm57JCR0eXBlb2Y6cCx0eXBlOmEudHlwZSxrZXk6ZyxyZWY6aCxwcm9wczplLF9vd25lcjpmfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1NLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0saXNWYWxpZEVsZW1lbnQ6Tix2ZXJzaW9uOlwiMTYuOC4zXCIsXG51bnN0YWJsZV9Db25jdXJyZW50TW9kZTp4LHVuc3RhYmxlX1Byb2ZpbGVyOnUsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6SSxSZWFjdEN1cnJlbnRPd25lcjpKLGFzc2lnbjprfX0sWT17ZGVmYXVsdDpYfSxaPVkmJlh8fFk7bW9kdWxlLmV4cG9ydHM9Wi5kZWZhdWx0fHxaO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval('module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "exports", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanM/ODJiMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(13);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsMkJBQTJCLG1CQUFPLENBQUMsRUFBNEI7O0FBRS9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG5lbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LnJlc2V0V2FybmluZ0NhY2hlID0gZW1wdHlGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGVsZW1lbnRUeXBlOiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW0sXG5cbiAgICBjaGVja1Byb3BUeXBlczogZW1wdHlGdW5jdGlvbldpdGhSZXNldCxcbiAgICByZXNldFdhcm5pbmdDYWNoZTogZW1wdHlGdW5jdGlvblxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// CONCATENATED MODULE: ./src/dependency-injection/buildInjectorContainer.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar buildInjectorContainer = function buildInjectorContainer() {\n  return {\n    /**\n     * A map of services\n     * @type {object}\n     */\n    services: {},\n\n    /**\n     * When true, DI is blocked\n     * @type {boolean}\n     */\n    initialised: false,\n    callbacks: [],\n\n    /**\n     * Register a service for the injector to provide\n     *\n     * @param key\n     * @param value\n     * @param force\n     */\n    register: function register(key, value) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          force = _ref.force;\n\n      if (this.initialised) {\n        throw new Error(\'Cannot mutate DI container after it has been initialised\');\n      }\n\n      if (this.services[key] && force !== true) {\n        throw new Error("\\n      Tried to register service ".concat(key, " more than once. This practice is discouraged. Consider\\n      using Injector.update() to enhance the service rather than override it completely.\\n      Otherwise, invoke the register() function with { force: true } as the third argument.\\n     "));\n      }\n\n      if (typeof this[key] !== \'undefined\' && !this.services[key]) {\n        throw new Error("\\n      Tried to register service ".concat(key, " which is a reserved keyword. This would affect the behaviour\\n      of this API class, so it is forbidden to register with Injector.\\n      "));\n      }\n\n      var requiredMethods = [\'load\', \'createTransformer\', \'get\', \'register\'];\n\n      if (!requiredMethods.every(function (method) {\n        return typeof value[method] === \'function\';\n      })) {\n        throw new Error("\\n      Tried to register service ".concat(key, " that is not a valid object, Injector requires an object\\n      which contains the following methods: ").concat(requiredMethods.join(\', \'), "\\n      "));\n      }\n\n      this.services[key] = value; // globally expose the service as well\n\n      this[key] = value;\n    },\n\n    /**\n     * Loads each service that was registered\n     */\n    load: function load() {\n      if (this.initialised) {\n        throw new Error(\'Cannot mutate DI container after it has been initialised\');\n      }\n\n      Object.values(this.services).forEach(function (service) {\n        return service.load();\n      });\n      this.initialised = true;\n      this.callbacks.forEach(function (callback) {\n        callback();\n      });\n      this.callbacks = [];\n    },\n\n    /**\n     * Provides an object to a callback which allows quick access to individual services\n     *\n     * @param {string} name The name of the transformation\n     * @param {function} callback\n     * @param {object} priorities An object mapping priorities for the loading order:\n     *  { before: \'some-transformation\', after: \'some-other-transformation\' }\n     */\n    transform: function transform(name, callback) {\n      var priorities = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.initialised) {\n        throw new Error(\'Cannot mutate DI container after it has been initialised\');\n      }\n\n      var updater = Object.entries(this.services).reduce(function (updateContainer, _ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            serviceName = _ref3[0],\n            service = _ref3[1];\n\n        return _objectSpread({}, updateContainer, _defineProperty({}, serviceName, service.createTransformer(name, priorities)));\n      }, {});\n      callback(updater);\n    },\n    ready: function ready(callback) {\n      if (typeof callback !== \'function\') {\n        throw new Error(\'Callback provided is not a function\');\n      }\n\n      if (this.initialised) {\n        callback();\n        return;\n      }\n\n      this.callbacks = [].concat(_toConsumableArray(this.callbacks), [callback]);\n    }\n  };\n};\n\n/* harmony default export */ var dependency_injection_buildInjectorContainer = (buildInjectorContainer);\n// EXTERNAL MODULE: ./node_modules/toposort/index.js\nvar toposort = __webpack_require__(4);\nvar toposort_default = /*#__PURE__*/__webpack_require__.n(toposort);\n\n// CONCATENATED MODULE: ./src/dependency-injection/MiddlewareRegistry.js\nfunction MiddlewareRegistry_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { MiddlewareRegistry_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction MiddlewareRegistry_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\n * @type {string}\n */\n\nvar BEFORE = \'before\';\n/**\n * @type {string}\n */\n\nvar AFTER = \'after\';\n/**\n * @type {string}\n */\n\nvar GRAPH_HEAD = \'__HEAD__\';\n/**\n * @type {string}\n */\n\nvar GRAPH_TAIL = \'__TAIL__\';\n/**\n * A list of allowed priorities that can be specified as metadata\n * @type {Array}\n */\n\nvar PRIORITIES = [BEFORE, AFTER];\n/**\n * The name of the default context, if none is given\n * @type {string}\n */\n\nvar GLOBAL_CONTEXT = \'__GLOBAL__\';\n/**\n * The wildcard operator, used for priorities\n * @type {string}\n */\n\nvar WILDCARD = \'*\';\n/**\n * Validates the metadata passed to the injector customisation\n * @param meta\n */\n\nvar validateMeta = function validateMeta(meta) {\n  PRIORITIES.forEach(function (k) {\n    if (typeof meta[k] !== \'undefined\' && typeof meta[k] !== \'string\' && !Array.isArray(meta[k])) {\n      throw new Error("Middleware key ".concat(k, " must be a string or array"));\n    }\n  });\n};\n/**\n * Validates the use of a wildcard (*) specification on a middleware object.\n * It should:\n * -- Be singular\n *  BAD: { after: [\'*\', \'something-else\'] }\n *  GOOD: { after: [\'*\'] }\n * -- Be the only priority rule\n *   BAD: { after: [\'*\'], before: \'something\' }\n *   GOOD: { after: [\'*\'] }\n * @param middleware\n * @returns The priority (before/after) of the wildcard being used\n */\n\n\nvar checkWildcard = function checkWildcard(middleware) {\n  var wildcard = null;\n  PRIORITIES.forEach(function (PRIORITY) {\n    if (middleware[PRIORITY].includes(WILDCARD)) {\n      if (middleware[PRIORITY].length > 1) {\n        throw new Error("\\n          Key ".concat(PRIORITY, " on ").concat(middleware.name, " should only specify one key \\n          if using the \\"").concat(WILDCARD, "\\" wildcard\\n        "));\n      } else if (wildcard) {\n        throw new Error("\\n          Cannot specify a ".concat(PRIORITY, " rule on ").concat(middleware.name, " if a wildcard \\n          has been specified\\n        "));\n      } else {\n        wildcard = PRIORITY;\n      }\n    }\n  });\n  return wildcard;\n};\n/**\n * The public API of the middleware registry. Holds a set of middlewares\n * for a given service and negotiates priorities and contexts to create\n * a factory. Factories are cached for each context.\n */\n\n\nvar MiddlewareRegistry_MiddlewareRegistry =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   */\n  function MiddlewareRegistry() {\n    _classCallCheck(this, MiddlewareRegistry);\n\n    this._middlewares = [];\n    this._contextCache = {};\n  }\n  /**\n   * Applies a topological sort to the middlewares and resolves\n   * priority declarations\n   */\n\n\n  _createClass(MiddlewareRegistry, [{\n    key: "sort",\n    value: function sort() {\n      var _this = this;\n\n      /* Initialise the graph with head and tail placeholders so that customisations\n       with no before/after specified have a reference point */\n      var GRAPH_INIT = [GRAPH_HEAD, GRAPH_TAIL];\n      var graph = [GRAPH_INIT];\n      var sortedMiddlewares = [];\n\n      this._middlewares.forEach(function (middleware) {\n        var name = middleware.name;\n        var wildcard = checkWildcard(middleware);\n\n        if (wildcard === AFTER) {\n          graph.push([GRAPH_TAIL, name]);\n        } else if (wildcard === BEFORE) {\n          graph.push([name, GRAPH_HEAD]);\n        } else {\n          // Everything, other than wildcards, goes between head and tail\n          // at a minimum\n          graph.push([name, GRAPH_TAIL]);\n          graph.push([GRAPH_HEAD, name]);\n          middleware[BEFORE].forEach(function (beforeEntry) {\n            graph.push([name, beforeEntry]);\n          });\n          middleware[AFTER].forEach(function (afterEntry) {\n            graph.push([afterEntry, name]);\n          });\n        }\n      }); // Apply the topological sort and strip out the placeholders\n\n\n      toposort_default()(graph).filter(function (item) {\n        return !GRAPH_INIT.includes(item);\n      }).forEach(function (name) {\n        sortedMiddlewares = sortedMiddlewares.concat(_this._middlewares.filter(function (m) {\n          return m.name === name;\n        }));\n      });\n      this._middlewares = sortedMiddlewares;\n      return this;\n    }\n    /**\n     * Adds new middleware to the list\n     * @param {object} meta An object of meta data { name, before, after }\n     * @param {function} factory The middleware (decorator) to apply to the service\n     * @param {Array} contextList An array of hierarchical context, [\'Universe\', \'Earth\', \'NZ\']\n     */\n\n  }, {\n    key: "add",\n    value: function add(meta, factory, contextList) {\n      validateMeta(meta); // Invalidate the cache when new middlewares are added\n\n      this._contextCache = {};\n      var context = contextList;\n\n      if (!context || !context.length) {\n        context = [GLOBAL_CONTEXT];\n      } else if (!Array.isArray(context)) {\n        context = [context];\n      }\n\n      var normalised = MiddlewareRegistry_objectSpread({}, meta, {\n        factory: factory,\n        context: context\n      }); // make sure before/after are at least empty arrays\n\n\n      PRIORITIES.forEach(function (k) {\n        if (!Array.isArray(meta[k])) {\n          normalised[k] = meta[k] ? [meta[k]] : [];\n        } else {\n          normalised[k] = meta[k];\n        }\n      }); // If no before/after is specified, put it between the head and tail\n\n      if (PRIORITIES.every(function (p) {\n        return !normalised[p].length;\n      })) {\n        normalised[AFTER] = [GRAPH_HEAD];\n        normalised[BEFORE] = [GRAPH_TAIL];\n      }\n\n      this._middlewares.push(normalised);\n\n      return this;\n    }\n    /**\n     * Given a dot-separated context spec, find all the registered middlewares that apply\n     * @param {string} context\n     * @returns {Array}\n     */\n\n  }, {\n    key: "getMatchesForContext",\n    value: function getMatchesForContext() {\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GLOBAL_CONTEXT;\n\n      if (!this._contextCache[context]) {\n        var requestedContext = context.split(\'.\');\n        this._contextCache[context] = this._middlewares.filter(function (middleware) {\n          return middleware.context[0] === GLOBAL_CONTEXT || middleware.context.every(function (part, index) {\n            return part === WILDCARD || requestedContext[index] === part;\n          });\n        });\n      }\n\n      return this._contextCache[context];\n    }\n  }]);\n\n  return MiddlewareRegistry;\n}();\n\n\n/* harmony default export */ var dependency_injection_MiddlewareRegistry = (MiddlewareRegistry_MiddlewareRegistry);\n// EXTERNAL MODULE: ./node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/redux/es/redux.js\n\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split(\'\').join(\'.\');\n};\n\nvar ActionTypes = {\n  INIT: "@@redux/INIT" + randomString(),\n  REPLACE: "@@redux/REPLACE" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== \'object\' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'function\' || typeof enhancer === \'function\' && typeof arguments[3] === \'function\') {\n    throw new Error(\'It looks like you are passing several store enhancers to \' + \'createStore(). This is not supported. Instead, compose them \' + \'together to a single function\');\n  }\n\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== \'function\') {\n    throw new Error(\'Expected the reducer to be a function.\');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(\'You may not call store.getState() while the reducer is executing. \' + \'The reducer has already received the state as an argument. \' + \'Pass it down from the top reducer instead of reading it from the store.\');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== \'function\') {\n      throw new Error(\'Expected the listener to be a function.\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'You may not call store.subscribe() while the reducer is executing. \' + \'If you would like to be notified after the store has been updated, subscribe from a \' + \'component and invoke store.getState() in the callback to access the latest state. \' + \'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(\'You may not unsubscribe from a store listener while the reducer is executing. \' + \'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\'Actions must be plain objects. \' + \'Use custom middleware for async actions.\');\n    }\n\n    if (typeof action.type === \'undefined\') {\n      throw new Error(\'Actions may not have an undefined "type" property. \' + \'Have you misspelled a constant?\');\n    }\n\n    if (isDispatching) {\n      throw new Error(\'Reducers may not dispatch actions.\');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \'function\') {\n      throw new Error(\'Expected the nextReducer to be a function.\');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== \'object\' || observer === null) {\n          throw new TypeError(\'Expected the observer to be an object.\');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[es["a" /* default */]] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an "INIT" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[es["a" /* default */]] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== \'undefined\' && typeof console.error === \'function\') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // "break on all exceptions" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && "action \\"" + String(actionType) + "\\"" || \'an action\';\n  return "Given " + actionDescription + ", reducer \\"" + key + "\\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? \'preloadedState argument passed to createStore\' : \'previous state received by the reducer\';\n\n  if (reducerKeys.length === 0) {\n    return \'Store does not have a valid reducer. Make sure the argument passed \' + \'to combineReducers is an object whose values are reducers.\';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return "The " + argumentName + " has unexpected type of \\"" + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + "\\". Expected argument to be an object with the following " + ("keys: \\"" + reducerKeys.join(\'", "\') + "\\"");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return "Unexpected " + (unexpectedKeys.length > 1 ? \'keys\' : \'key\') + " " + ("\\"" + unexpectedKeys.join(\'", "\') + "\\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\\"" + reducerKeys.join(\'", "\') + "\\". Unexpected keys will be ignored.");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === \'undefined\') {\n      throw new Error("Reducer \\"" + key + "\\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don\'t want to set a value for this reducer, " + "you can use null instead of undefined.");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === \'undefined\') {\n      throw new Error("Reducer \\"" + key + "\\" returned undefined when probed with a random type. " + ("Don\'t try to handle " + ActionTypes.INIT + " or other actions in \\"redux/*\\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (false) {}\n\n    if (typeof reducers[key] === \'function\') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers);\n  var unexpectedKeyCache;\n\n  if (false) {}\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (false) { var warningMessage; }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === \'undefined\') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \'function\') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== \'object\' || actionCreators === null) {\n    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? \'null\' : typeof actionCreators) + ". " + "Did you write \\"import ActionCreators from\\" instead of \\"import * as ActionCreators from\\"?");\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === \'function\') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\nfunction redux_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction redux_objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \'function\') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      redux_defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return redux_objectSpread({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== \'production\', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (false) {}\n\n\n\n// CONCATENATED MODULE: ./src/dependency-injection/buildBaseContainer.js\nfunction buildBaseContainer_toConsumableArray(arr) { return buildBaseContainer_arrayWithoutHoles(arr) || buildBaseContainer_iterableToArray(arr) || buildBaseContainer_nonIterableSpread(); }\n\nfunction buildBaseContainer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction buildBaseContainer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction buildBaseContainer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { buildBaseContainer_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction buildBaseContainer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toArray(arr) { return buildBaseContainer_arrayWithHoles(arr) || buildBaseContainer_iterableToArray(arr) || buildBaseContainer_nonIterableRest(); }\n\nfunction buildBaseContainer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }\n\nfunction buildBaseContainer_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction buildBaseContainer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\nvar buildBaseContainer_buildBaseContainer = function buildBaseContainer() {\n  return {\n    /**\n     * Store of middleware registries\n     * @type {object}\n     */\n    middlewareRegistries: {},\n\n    /**\n     * A map of services\n     * @type {object}\n     */\n    services: {},\n\n    /**\n     * A map of factories to the services\n     * @type {object}\n     */\n    factories: {},\n    factoryCache: {},\n\n    /**\n     * When true, DI is blocked\n     * @type {boolean}\n     */\n    initialised: false,\n    isProtected: function isProtected() {\n      if (this.initialised) {\n        throw new Error(\'Cannot mutate DI container after it has been initialised\');\n      }\n    },\n\n    /**\n     * Gets a dependency\n     * @param {string} key\n     * @param {string} context A dot-separated context specification\n     * @returns {object} Component\n     */\n    get: function get(key, context) {\n      if (!this.initialised) {\n        throw new Error("\\n      Injector.get(): Attempted to access DI layer before it was initialised.\\n      Did you forget to invoke Injector.load()?");\n      }\n\n      var factory = this.factories[key];\n\n      if (!factory) {\n        throw new Error("Injector.get(): Component ".concat(key, " does not exist"));\n      }\n\n      return factory(context);\n    },\n\n    /**\n     * Applies a middleware function to compose an existing component\n     * with new properties\n     * @param {object} meta An object of metadata\n     * @param {string} key The name of the dependency to customise\n     * @param {function} factory The function that will compose the dependency. Gets passed the\n     *  previous state of composition\n     */\n    customise: function customise(meta, key, factory) {\n      this.isProtected();\n\n      var _key$split = key.split(\'.\'),\n          _key$split2 = _toArray(_key$split),\n          serviceName = _key$split2[0],\n          context = _key$split2.slice(1);\n\n      var registry = this.middlewareRegistries[serviceName];\n\n      if (!registry) {\n        registry = new dependency_injection_MiddlewareRegistry();\n        this.middlewareRegistries = buildBaseContainer_objectSpread({}, this.middlewareRegistries, buildBaseContainer_defineProperty({}, serviceName, registry));\n      }\n\n      registry.add(meta, factory, context);\n    },\n\n    /**\n     * Resolve all of the middleware constraints and freeze the DI layer\n     */\n    load: function load() {\n      var _this = this;\n\n      this.isProtected();\n      this.factories = Object.keys(this.services).reduce(function (factories, key) {\n        var middleware = _this.middlewareRegistries[key];\n\n        if (middleware) {\n          middleware.sort();\n          return buildBaseContainer_objectSpread({}, factories, buildBaseContainer_defineProperty({}, key, function () {\n            var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GLOBAL_CONTEXT;\n            var cacheKey = "".concat(key, "__").concat(context);\n\n            if (!_this.factoryCache[cacheKey]) {\n              var matches = middleware.getMatchesForContext(context);\n              _this.factoryCache[cacheKey] = _this.getFactory(key, matches);\n            }\n\n            return _this.factoryCache[cacheKey];\n          }));\n        }\n\n        return buildBaseContainer_objectSpread({}, factories, buildBaseContainer_defineProperty({}, key, function () {\n          return _this.getFactory(key, []);\n        }));\n      }, {});\n      this.initialised = true;\n    },\n\n    /**\n     * Register a dependency. This is the initial version of a dependency that will be\n     * passed to the first link in the middleware chain (if any customisations exist)\n     *\n     * @param {string} key - The name of the dependency to register\n     * @param {function} value - The component to register\n     * @param {boolean} force - Whether to force the given key to override an existing key\n     */\n    register: function register(key, value) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          force = _ref.force;\n\n      this.isProtected();\n\n      if (this.services[key] && force !== true) {\n        throw new Error("\\n      Tried to register service \'".concat(key, "\' more than once. This practice is discouraged. Consider\\n      using Injector.update() to enhance the service rather than override it completely.\\n      Otherwise, invoke the register() function with { force: true } as the third argument.\\n     "));\n      }\n\n      this.services = buildBaseContainer_objectSpread({}, this.services, buildBaseContainer_defineProperty({}, key, value));\n    },\n\n    /**\n     * Register many dependencies. This will be a list of the initial version of a dependency that\n     * will be passed to the first link in the middleware chain (if any customisations exist)\n     *\n     * @param {object} map - The name-value mapping of the dependencies to register\n     * @param {boolean} force - Whether to force the given key to override an existing key\n     */\n    registerMany: function registerMany(map) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          force = _ref2.force;\n\n      this.isProtected();\n      var mapKeys = Object.keys(map);\n      var existing = Object.keys(this.services).filter(function (service) {\n        return mapKeys.includes(service);\n      });\n\n      if (existing.length && force !== true) {\n        var list = existing.join(\', \');\n        throw new Error("\\n      Tried to register services (".concat(list, ") more than once. This practice is discouraged. Consider\\n      using Injector.update() to enhance the service rather than override it completely.\\n      Otherwise, invoke the register() function with { force: true } as the third argument.\\n     "));\n      }\n\n      this.services = buildBaseContainer_objectSpread({}, this.services, map);\n    },\n\n    /**\n     * Updates the injector by callback. First parameter should contain\n     * an object with keys for name, and (optional) "before" and "after" declarations\n     * e.x.\n     * Injector.transform(\'my-transformation-name\', (update) => {\n     *  update(\'SomeComponent\', MyNewComponentCreator);\n     * }, { before: \'another-transform\' });\n     * @param {string} name The name of the transformation\n     * @param {function} callback\n     * @param {object} priorities An object mapping priorities for the loading order:\n     *  { before: \'some-transformation\', after: \'some-other-transformation\' }\n     */\n    transform: function transform(name, callback) {\n      var priorities = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.isProtected();\n      callback(this.createTransformer(name, priorities));\n    },\n\n    /**\n     * Creates a customise() function for a transformation\n     * @param {string} name\n     * @param {object} priorities\n     * @returns {function}\n     */\n    createTransformer: function createTransformer(name, priorities) {\n      var _this2 = this;\n\n      return function (key, wrapper) {\n        _this2.customise(buildBaseContainer_objectSpread({\n          name: name\n        }, priorities), key, wrapper);\n      };\n    },\n\n    /**\n     * Creates a factory method for a service, incorporating all the given middleware.\n     * @param {string} key\n     * @param {Array} middlewareMatches\n     * @returns {function}\n     */\n    getFactory: function getFactory(key, middlewareMatches) {\n      var service = this.services[key];\n      var middlewares = middlewareMatches.map(function (m) {\n        return m.factory;\n      });\n      return compose.apply(void 0, buildBaseContainer_toConsumableArray(middlewares))(service);\n    }\n  };\n};\n\n/* harmony default export */ var dependency_injection_buildBaseContainer = (buildBaseContainer_buildBaseContainer);\n// CONCATENATED MODULE: ./src/dependency-injection/buildComponentContainer.js\nfunction buildComponentContainer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { buildComponentContainer_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction buildComponentContainer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction buildComponentContainer_toConsumableArray(arr) { return buildComponentContainer_arrayWithoutHoles(arr) || buildComponentContainer_iterableToArray(arr) || buildComponentContainer_nonIterableSpread(); }\n\nfunction buildComponentContainer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction buildComponentContainer_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction buildComponentContainer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n\n/**\n * Creates a display name for a final composed component given all\n * the names of the mutations that affected it.\n * e.g. my-transformation(TextField)\n * @param original The original registered component\n * @param transforms The list of transformation names that modified the component\n */\n\nvar createDisplayName = function createDisplayName(original, transforms) {\n  var componentName = original.displayName || original.name || \'Component\';\n  var names = [componentName].concat(buildComponentContainer_toConsumableArray(transforms));\n  return names.reduce(function (acc, curr) {\n    return "".concat(curr, "(").concat(acc, ")");\n  });\n};\n\nvar buildComponentContainer_buildComponentContainer = function buildComponentContainer() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : dependency_injection_buildBaseContainer();\n  return buildComponentContainer_objectSpread({}, base, {\n    /**\n     * Extends base.get to add a displayName to the service\n     *\n     * @param key\n     * @param context\n     * @param args\n     * @returns {XML}\n     */\n    get: function get(key, context) {\n      var _base$get;\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var service = (_base$get = base.get).call.apply(_base$get, [this, key, context].concat(args));\n\n      if (service.displayName && service.displayName.match(/\\]$/)) {\n        return service;\n      }\n\n      var componentName = service.displayName || service.name || \'Component\';\n      var componentKey = context ? "[".concat(context, "]") : \'\'; // @todo this causes incorrect context to display if this service is used in different contexts\n\n      service.displayName = "".concat(componentName).concat(componentKey);\n      return service;\n    },\n\n    /**\n     * Creates a customise() function for a transformation\n     * @param {string} name\n     * @param {object} priorities\n     * @returns {function}\n     */\n    createTransformer: function createTransformer(name, priorities) {\n      var _this = this;\n\n      return function (key, wrapper, displayName) {\n        _this.customise(buildComponentContainer_objectSpread({\n          name: name\n        }, priorities, {\n          displayName: displayName\n        }), key, wrapper);\n      };\n    },\n\n    /**\n     * Creates a factory method for a service, incorporating all the given middleware.\n     * @param {string} key\n     * @param {array} middlewareMatches\n     * @returns {function}\n     */\n    getFactory: function getFactory(key, middlewareMatches) {\n      var factory = base.getFactory.call(this, key, middlewareMatches);\n      var names = middlewareMatches.map(function (middleware) {\n        return middleware.displayName || middleware.name;\n      });\n      factory.displayName = createDisplayName(this.services[key], names);\n      return factory;\n    }\n  });\n};\n\n/* harmony default export */ var dependency_injection_buildComponentContainer = (buildComponentContainer_buildComponentContainer);\n// CONCATENATED MODULE: ./src/dependency-injection/buildReducerContainer.js\nfunction buildReducerContainer_slicedToArray(arr, i) { return buildReducerContainer_arrayWithHoles(arr) || buildReducerContainer_iterableToArrayLimit(arr, i) || buildReducerContainer_nonIterableRest(); }\n\nfunction buildReducerContainer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }\n\nfunction buildReducerContainer_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction buildReducerContainer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction buildReducerContainer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { buildReducerContainer_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction buildReducerContainer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar buildReducerContainer_buildReducerContainer = function buildReducerContainer() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : dependency_injection_buildBaseContainer();\n  return buildReducerContainer_objectSpread({}, base, {\n    /**\n     * The redux store which will be providing the global context for the reducer middleware\n     * @type {object}\n     */\n    store: null,\n    setStore: function setStore(store) {\n      this.store = store;\n    },\n\n    /**\n     * Applies a middleware function to compose an existing component\n     * with new properties.\n     * Note: overrides base.customise because reducers do not have context\n     *\n     * @param {object} meta An object of metadata\n     * @param {string} key The name of the dependency to customise\n     * @param {function} factory The function that will compose the dependency. Gets passed the\n     *  previous state of composition\n     */\n    customise: function customise(meta, key, factory) {\n      var _this = this;\n\n      this.isProtected();\n      var registry = this.middlewareRegistries[key];\n\n      if (!registry) {\n        registry = new dependency_injection_MiddlewareRegistry();\n        this.middlewareRegistries = buildReducerContainer_objectSpread({}, this.middlewareRegistries, buildReducerContainer_defineProperty({}, key, registry));\n      }\n\n      var enhancedFactory = function enhancedFactory(service) {\n        var getState = _this.store && _this.store.getState;\n        return factory(service)(getState);\n      };\n\n      registry.add(meta, enhancedFactory);\n    },\n    getAll: function getAll() {\n      var newFactories = this.initialised ? Object.entries(this.factories).reduce(function (prev, _ref) {\n        var _ref2 = buildReducerContainer_slicedToArray(_ref, 2),\n            key = _ref2[0],\n            factory = _ref2[1];\n\n        return buildReducerContainer_objectSpread({}, prev, buildReducerContainer_defineProperty({}, key, factory()));\n      }, {}) // return the services registered if we haven\'t initialised yet.\n      : Object.entries(this.services).reduce(function (prev, _ref3) {\n        var _ref4 = buildReducerContainer_slicedToArray(_ref3, 2),\n            key = _ref4[0],\n            service = _ref4[1];\n\n        return buildReducerContainer_objectSpread({}, prev, buildReducerContainer_defineProperty({}, key, service));\n      }, {});\n      return newFactories;\n    }\n  });\n};\n\n/* harmony default export */ var dependency_injection_buildReducerContainer = (buildReducerContainer_buildReducerContainer);\n// CONCATENATED MODULE: ./src/dependency-injection/Container.js\n\n\n\nvar Container_Injector = dependency_injection_buildInjectorContainer();\nContainer_Injector.register(\'component\', dependency_injection_buildComponentContainer());\nContainer_Injector.register(\'reducer\', dependency_injection_buildReducerContainer());\n/* harmony default export */ var Container = (Container_Injector);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(1);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// CONCATENATED MODULE: ./src/dependency-injection/injectorContext.js\n\n/* harmony default export */ var injectorContext = ({\n  injector: prop_types_default.a.shape({\n    get: prop_types_default.a.func,\n    context: prop_types_default.a.string,\n    validate: prop_types_default.a.func\n  })\n});\n// CONCATENATED MODULE: ./src/dependency-injection/provideInjector.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction provideInjector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction provideInjector_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction provideInjector_createClass(Constructor, protoProps, staticProps) { if (protoProps) provideInjector_defineProperties(Constructor.prototype, protoProps); if (staticProps) provideInjector_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nfunction provideInjector(Injectable) {\n  var injectorContainer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Container;\n\n  var InjectorProvider =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(InjectorProvider, _Component);\n\n    function InjectorProvider() {\n      provideInjector_classCallCheck(this, InjectorProvider);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(InjectorProvider).apply(this, arguments));\n    }\n\n    provideInjector_createClass(InjectorProvider, [{\n      key: "getChildContext",\n      value: function getChildContext() {\n        var component = injectorContainer.component;\n        return {\n          injector: {\n            get: component.get.bind(component)\n          }\n        };\n      }\n    }, {\n      key: "render",\n      value: function render() {\n        return react_default.a.createElement(Injectable, this.props);\n      }\n    }]);\n\n    return InjectorProvider;\n  }(react["Component"]);\n\n  InjectorProvider.childContextTypes = injectorContext;\n  return InjectorProvider;\n}\n\n/* harmony default export */ var dependency_injection_provideInjector = (provideInjector);\n// CONCATENATED MODULE: ./src/dependency-injection/provideContext.js\nfunction provideContext_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { provideContext_typeof = function _typeof(obj) { return typeof obj; }; } else { provideContext_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return provideContext_typeof(obj); }\n\nfunction provideContext_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { provideContext_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction provideContext_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction provideContext_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction provideContext_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction provideContext_createClass(Constructor, protoProps, staticProps) { if (protoProps) provideContext_defineProperties(Constructor.prototype, protoProps); if (staticProps) provideContext_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction provideContext_possibleConstructorReturn(self, call) { if (call && (provideContext_typeof(call) === "object" || typeof call === "function")) { return call; } return provideContext_assertThisInitialized(self); }\n\nfunction provideContext_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction provideContext_getPrototypeOf(o) { provideContext_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return provideContext_getPrototypeOf(o); }\n\nfunction provideContext_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) provideContext_setPrototypeOf(subClass, superClass); }\n\nfunction provideContext_setPrototypeOf(o, p) { provideContext_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return provideContext_setPrototypeOf(o, p); }\n\n\n\n\nvar provideContext_provideContext = function provideContext(context) {\n  return function (ContextualComponent) {\n    var ContextProvider =\n    /*#__PURE__*/\n    function (_Component) {\n      provideContext_inherits(ContextProvider, _Component);\n\n      function ContextProvider() {\n        provideContext_classCallCheck(this, ContextProvider);\n\n        return provideContext_possibleConstructorReturn(this, provideContext_getPrototypeOf(ContextProvider).apply(this, arguments));\n      }\n\n      provideContext_createClass(ContextProvider, [{\n        key: "getChildContext",\n        value: function getChildContext() {\n          return {\n            injector: provideContext_objectSpread({}, this.context.injector, {\n              context: context\n            })\n          };\n        }\n      }, {\n        key: "render",\n        value: function render() {\n          return react_default.a.createElement(ContextualComponent, this.props);\n        }\n      }]);\n\n      return ContextProvider;\n    }(react["Component"]);\n\n    ContextProvider.contextTypes = injectorContext;\n    ContextProvider.childContextTypes = injectorContext;\n    return ContextProvider;\n  };\n};\n\n/* harmony default export */ var dependency_injection_provideContext = (provideContext_provideContext);\n// CONCATENATED MODULE: ./src/dependency-injection/withInjector.js\nfunction withInjector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { withInjector_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction withInjector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar withInjector_withInjector = function withInjector(Component) {\n  // eslint-disable-next-line no-param-reassign\n  Component.contextTypes = withInjector_objectSpread({}, Component.contextTypes || {}, injectorContext); // eslint-disable-next-line no-param-reassign\n\n  Component.displayName = "withInjector(\\n    ".concat(Component.displayName || Component.name || \'Component\', "\\n  )");\n  return Component;\n};\n\n/* harmony default export */ var dependency_injection_withInjector = (withInjector_withInjector);\n// CONCATENATED MODULE: ./src/dependency-injection/inject.js\nfunction inject_toConsumableArray(arr) { return inject_arrayWithoutHoles(arr) || inject_iterableToArray(arr) || inject_nonIterableSpread(); }\n\nfunction inject_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction inject_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction inject_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction inject_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { inject_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction inject_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction inject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction inject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction inject_createClass(Constructor, protoProps, staticProps) { if (protoProps) inject_defineProperties(Constructor.prototype, protoProps); if (staticProps) inject_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction inject_possibleConstructorReturn(self, call) { if (call && (inject_typeof(call) === "object" || typeof call === "function")) { return call; } return inject_assertThisInitialized(self); }\n\nfunction inject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction inject_getPrototypeOf(o) { inject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return inject_getPrototypeOf(o); }\n\nfunction inject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) inject_setPrototypeOf(subClass, superClass); }\n\nfunction inject_setPrototypeOf(o, p) { inject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return inject_setPrototypeOf(o, p); }\n\nfunction inject_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { inject_typeof = function _typeof(obj) { return typeof obj; }; } else { inject_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return inject_typeof(obj); }\n\n\n\n\nvar defaultContext = function defaultContext(props, injectorContext) {\n  return injectorContext;\n};\n/**\n * Injects dependences from the Injector as named props into a component\n * @param {Array} dependencies A list of named dependencies\n * @param {function} mapDependenciesToProps Maps the fetched dependencies to propnames, e.g.\n *   (TextField, FormAction) => { myText: TextField, myAction: FormAction }\n * @param {function} getContext Gets the name of the context to pass to Injector.\n *   Accepts the component\'s props as a param. (props) => `SomeContext.${props.identifier}`;\n */\n\n\nvar inject_inject = function inject(dependencies, mapDependenciesToProps) {\n  var getContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\n  return function (InjectingComponent) {\n    if (dependencies && !Array.isArray(dependencies)) {\n      throw new Error("\\n      withInjector() passed an argument for dependencies that is ".concat(typeof deps === "undefined" ? "undefined" : inject_typeof(deps), ". \\n      Must be an array of named dependencies.\\n    "));\n    }\n\n    if (mapDependenciesToProps && typeof mapDependenciesToProps !== \'function\') {\n      throw new Error("\\n      Second parameter of inject() [mapDependenciesToProps] must be a function, taking the resolved\\n      dependencies as enumerated arguments, and returning a map of prop names to dependencies.\\n    ");\n    }\n\n    if (typeof getContext !== \'function\') {\n      throw new Error("\\n      Third parameter of inject() [getContext] must be a function, taking the component\'s props\\n      and current inject context as parameters, and returning a string representing the Injector\\n      context to use throughout the component.\\n    ");\n    } // eslint-disable-next-line react/prefer-stateless-function\n\n\n    var Injector =\n    /*#__PURE__*/\n    function (_Component) {\n      inject_inherits(Injector, _Component);\n\n      function Injector(props, context) {\n        var _this;\n\n        inject_classCallCheck(this, Injector);\n\n        _this = inject_possibleConstructorReturn(this, inject_getPrototypeOf(Injector).call(this, props, context));\n        _this.state = {\n          context: getContext(props, context.injector.context)\n        };\n        return _this;\n      }\n\n      inject_createClass(Injector, [{\n        key: "getChildContext",\n        value: function getChildContext() {\n          return {\n            injector: inject_objectSpread({}, this.context.injector, {\n              context: this.state.context\n            })\n          };\n        }\n      }, {\n        key: "componentWillReceiveProps",\n        value: function componentWillReceiveProps(nextProps, nextContext) {\n          var newContext = getContext(nextProps, nextContext.injector.context);\n\n          if (newContext !== this.state.context) {\n            this.setState({\n              context: newContext\n            });\n          }\n        }\n      }, {\n        key: "render",\n        value: function render() {\n          var _this2 = this;\n\n          var props = {};\n\n          if (dependencies) {\n            var get = this.context.injector.get;\n            var resolved = dependencies.map(function (dep) {\n              return get(dep, _this2.state.context);\n            });\n\n            if (mapDependenciesToProps) {\n              props = mapDependenciesToProps.apply(void 0, inject_toConsumableArray(resolved));\n            } else {\n              // If no mapping function is given, mirror the prop names and dependency names\n              dependencies.forEach(function (dep, index) {\n                props[dep] = resolved[index];\n              });\n            }\n\n            if (!props || inject_typeof(props) !== \'object\') {\n              throw new Error("\\n            mapDepedenciesToProps parameter passed to inject()\\n            should return an object that maps prop names to dependencies\\n          ");\n            }\n          }\n\n          var newProps = inject_objectSpread({}, props, this.props);\n\n          return react_default.a.createElement(InjectingComponent, newProps);\n        }\n      }]);\n\n      return Injector;\n    }(react["Component"]);\n\n    Injector.contextTypes = injectorContext;\n    Injector.childContextTypes = injectorContext;\n    return Injector;\n  };\n};\n\n/* harmony default export */ var dependency_injection_inject = (inject_inject);\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(6);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// CONCATENATED MODULE: ./src/components/NotFoundComponent/NotFoundComponent.js\n\n\n\n\nvar NotFoundComponent_NotFoundComponent = function NotFoundComponent(_ref) {\n  var itemName = _ref.itemName,\n      name = _ref.name,\n      value = _ref.value;\n  return react_default.a.createElement("div", {\n    className: classnames_default()(itemName, \'not-found-component\')\n  }, react_default.a.createElement("div", null, "Failed to load component!"), name && typeof value === \'string\' ? react_default.a.createElement("input", {\n    type: "hidden",\n    name: name,\n    value: value\n  }) : null);\n};\n\nNotFoundComponent_NotFoundComponent.propTypes = {\n  itemName: prop_types_default.a.string.isRequired,\n  name: prop_types_default.a.string,\n  value: prop_types_default.a.any\n};\n/* harmony default export */ var components_NotFoundComponent_NotFoundComponent = (NotFoundComponent_NotFoundComponent);\n// CONCATENATED MODULE: ./src/dependency-injection/loadComponent.js\nfunction loadComponent_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { loadComponent_typeof = function _typeof(obj) { return typeof obj; }; } else { loadComponent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return loadComponent_typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction loadComponent_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === \'function\') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { loadComponent_defineProperty(target, key, source[key]); }); } return target; }\n\nfunction loadComponent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction loadComponent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction loadComponent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction loadComponent_createClass(Constructor, protoProps, staticProps) { if (protoProps) loadComponent_defineProperties(Constructor.prototype, protoProps); if (staticProps) loadComponent_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction loadComponent_possibleConstructorReturn(self, call) { if (call && (loadComponent_typeof(call) === "object" || typeof call === "function")) { return call; } return loadComponent_assertThisInitialized(self); }\n\nfunction loadComponent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction loadComponent_getPrototypeOf(o) { loadComponent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return loadComponent_getPrototypeOf(o); }\n\nfunction loadComponent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) loadComponent_setPrototypeOf(subClass, superClass); }\n\nfunction loadComponent_setPrototypeOf(o, p) { loadComponent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return loadComponent_setPrototypeOf(o, p); }\n\n/* global window */\n\n\n\n\n\n\n/**\n * Handles loading SilverStripe-centric providers\n * These options can be overridden by providing a context object\n *\n * Ensures that Injector is ready before the provided component will be rendered.\n *\n * @param targetName\n * @param context - properties include the following\n *    - store for the redux store\n *    - apolloClient for the apollo client (graphql)\n *    - context for filtering/applying transformations to the obtained component\n * @param overrideInjector\n */\n\nvar loadComponent_loadComponent = function loadComponent(targetName) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var overrideInjector = arguments.length > 2 ? arguments[2] : undefined;\n\n  var LegacyLoader =\n  /*#__PURE__*/\n  function (_Component) {\n    loadComponent_inherits(LegacyLoader, _Component);\n\n    function LegacyLoader(props) {\n      var _this;\n\n      loadComponent_classCallCheck(this, LegacyLoader);\n\n      _this = loadComponent_possibleConstructorReturn(this, loadComponent_getPrototypeOf(LegacyLoader).call(this, props));\n      _this.state = {\n        target: null,\n        error: false\n      };\n      return _this;\n    }\n\n    loadComponent_createClass(LegacyLoader, [{\n      key: "getChildContext",\n      value: function getChildContext() {\n        var injectorContext = context && context.context;\n\n        if (!injectorContext) {\n          return this.context;\n        }\n\n        return {\n          injector: loadComponent_objectSpread({}, this.context.injector, {\n            context: injectorContext\n          })\n        };\n      }\n    }, {\n      key: "componentWillMount",\n      value: function componentWillMount() {\n        var _this2 = this;\n\n        Container.ready(function () {\n          if (typeof targetName === \'string\') {\n            var error = true;\n            var target = null;\n\n            try {\n              target = _this2.context.injector.get(targetName, context && context.context);\n              error = false;\n            } catch (e) {\n              _this2.setState({\n                target: target,\n                error: error\n              }); // re-throw the error, as we do not want to silence it in the console\n\n\n              throw e;\n            }\n\n            _this2.setState({\n              target: target,\n              error: error\n            });\n\n            return;\n          }\n\n          _this2.setState({\n            target: targetName\n          });\n        });\n      }\n    }, {\n      key: "render",\n      value: function render() {\n        var Target = this.state.target;\n\n        if (this.state.error) {\n          var NotFound = components_NotFoundComponent_NotFoundComponent;\n\n          try {\n            NotFound = this.context.injector.get(\'NotFoundComponent\');\n          } catch (e) {// can\'t throw and return... together.\n          }\n\n          return react_default.a.createElement(NotFound, _extends({}, this.props, {\n            itemName: targetName\n          }));\n        }\n\n        if (Target) {\n          return react_default.a.createElement(Target, this.props);\n        }\n\n        return null;\n      }\n    }]);\n\n    return LegacyLoader;\n  }(react["Component"]);\n\n  LegacyLoader.childContextTypes = injectorContext;\n  var contextInjector = overrideInjector || dependency_injection_provideInjector;\n  return contextInjector(dependency_injection_withInjector(LegacyLoader));\n};\n\n/* harmony default export */ var dependency_injection_loadComponent = (loadComponent_loadComponent);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./src/Injector.js\n/* concated harmony reexport provideInjector */__webpack_require__.d(__webpack_exports__, "provideInjector", function() { return dependency_injection_provideInjector; });\n/* concated harmony reexport provideContext */__webpack_require__.d(__webpack_exports__, "provideContext", function() { return dependency_injection_provideContext; });\n/* concated harmony reexport withInjector */__webpack_require__.d(__webpack_exports__, "withInjector", function() { return dependency_injection_withInjector; });\n/* concated harmony reexport inject */__webpack_require__.d(__webpack_exports__, "inject", function() { return dependency_injection_inject; });\n/* concated harmony reexport loadComponent */__webpack_require__.d(__webpack_exports__, "loadComponent", function() { return dependency_injection_loadComponent; });\n\n\n\n\n\n\n\n/* harmony default export */ var lib_src_Injector = __webpack_exports__["default"] = (Container);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVwZW5kZW5jeS1pbmplY3Rpb24vYnVpbGRJbmplY3RvckNvbnRhaW5lci5qcz8wODIwIiwid2VicGFjazovLy8uL3NyYy9kZXBlbmRlbmN5LWluamVjdGlvbi9NaWRkbGV3YXJlUmVnaXN0cnkuanM/YzA3OSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanM/MDBkOCIsIndlYnBhY2s6Ly8vLi9zcmMvZGVwZW5kZW5jeS1pbmplY3Rpb24vYnVpbGRCYXNlQ29udGFpbmVyLmpzPzZlZDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlcGVuZGVuY3ktaW5qZWN0aW9uL2J1aWxkQ29tcG9uZW50Q29udGFpbmVyLmpzP2MyYjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlcGVuZGVuY3ktaW5qZWN0aW9uL2J1aWxkUmVkdWNlckNvbnRhaW5lci5qcz80MTkwIiwid2VicGFjazovLy8uL3NyYy9kZXBlbmRlbmN5LWluamVjdGlvbi9Db250YWluZXIuanM/ODQ5YSIsIndlYnBhY2s6Ly8vLi9zcmMvZGVwZW5kZW5jeS1pbmplY3Rpb24vaW5qZWN0b3JDb250ZXh0LmpzP2M3ZTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlcGVuZGVuY3ktaW5qZWN0aW9uL3Byb3ZpZGVJbmplY3Rvci5qcz84NmRkIiwid2VicGFjazovLy8uL3NyYy9kZXBlbmRlbmN5LWluamVjdGlvbi9wcm92aWRlQ29udGV4dC5qcz82YTA3Iiwid2VicGFjazovLy8uL3NyYy9kZXBlbmRlbmN5LWluamVjdGlvbi93aXRoSW5qZWN0b3IuanM/YzZhOSIsIndlYnBhY2s6Ly8vLi9zcmMvZGVwZW5kZW5jeS1pbmplY3Rpb24vaW5qZWN0LmpzPzkzMzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTm90Rm91bmRDb21wb25lbnQvTm90Rm91bmRDb21wb25lbnQuanM/NmU4MiIsIndlYnBhY2s6Ly8vLi9zcmMvZGVwZW5kZW5jeS1pbmplY3Rpb24vbG9hZENvbXBvbmVudC5qcz8wNTFhIiwid2VicGFjazovLy8uL3NyYy9JbmplY3Rvci5qcz8zYzg2Il0sIm5hbWVzIjpbImJ1aWxkSW5qZWN0b3JDb250YWluZXIiLCJzZXJ2aWNlcyIsImluaXRpYWxpc2VkIiwiY2FsbGJhY2tzIiwicmVnaXN0ZXIiLCJrZXkiLCJ2YWx1ZSIsImZvcmNlIiwiRXJyb3IiLCJyZXF1aXJlZE1ldGhvZHMiLCJldmVyeSIsIm1ldGhvZCIsImpvaW4iLCJsb2FkIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInNlcnZpY2UiLCJjYWxsYmFjayIsInRyYW5zZm9ybSIsIm5hbWUiLCJwcmlvcml0aWVzIiwidXBkYXRlciIsImVudHJpZXMiLCJyZWR1Y2UiLCJ1cGRhdGVDb250YWluZXIiLCJzZXJ2aWNlTmFtZSIsImNyZWF0ZVRyYW5zZm9ybWVyIiwicmVhZHkiLCJCRUZPUkUiLCJBRlRFUiIsIkdSQVBIX0hFQUQiLCJHUkFQSF9UQUlMIiwiUFJJT1JJVElFUyIsIkdMT0JBTF9DT05URVhUIiwiV0lMRENBUkQiLCJ2YWxpZGF0ZU1ldGEiLCJtZXRhIiwiayIsIkFycmF5IiwiaXNBcnJheSIsImNoZWNrV2lsZGNhcmQiLCJtaWRkbGV3YXJlIiwid2lsZGNhcmQiLCJQUklPUklUWSIsImluY2x1ZGVzIiwibGVuZ3RoIiwiTWlkZGxld2FyZVJlZ2lzdHJ5IiwiX21pZGRsZXdhcmVzIiwiX2NvbnRleHRDYWNoZSIsIkdSQVBIX0lOSVQiLCJncmFwaCIsInNvcnRlZE1pZGRsZXdhcmVzIiwicHVzaCIsImJlZm9yZUVudHJ5IiwiYWZ0ZXJFbnRyeSIsInRvcG9zb3J0IiwiZmlsdGVyIiwiaXRlbSIsImNvbmNhdCIsIm0iLCJmYWN0b3J5IiwiY29udGV4dExpc3QiLCJjb250ZXh0Iiwibm9ybWFsaXNlZCIsInAiLCJyZXF1ZXN0ZWRDb250ZXh0Iiwic3BsaXQiLCJwYXJ0IiwiaW5kZXgiLCJidWlsZEJhc2VDb250YWluZXIiLCJtaWRkbGV3YXJlUmVnaXN0cmllcyIsImZhY3RvcmllcyIsImZhY3RvcnlDYWNoZSIsImlzUHJvdGVjdGVkIiwiZ2V0IiwiY3VzdG9taXNlIiwicmVnaXN0cnkiLCJhZGQiLCJrZXlzIiwic29ydCIsImNhY2hlS2V5IiwibWF0Y2hlcyIsImdldE1hdGNoZXNGb3JDb250ZXh0IiwiZ2V0RmFjdG9yeSIsInJlZ2lzdGVyTWFueSIsIm1hcCIsIm1hcEtleXMiLCJleGlzdGluZyIsImxpc3QiLCJ3cmFwcGVyIiwibWlkZGxld2FyZU1hdGNoZXMiLCJtaWRkbGV3YXJlcyIsImNvbXBvc2UiLCJjcmVhdGVEaXNwbGF5TmFtZSIsIm9yaWdpbmFsIiwidHJhbnNmb3JtcyIsImNvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWVzIiwiYWNjIiwiY3VyciIsImJ1aWxkQ29tcG9uZW50Q29udGFpbmVyIiwiYmFzZSIsImFyZ3MiLCJjYWxsIiwibWF0Y2giLCJjb21wb25lbnRLZXkiLCJidWlsZFJlZHVjZXJDb250YWluZXIiLCJzdG9yZSIsInNldFN0b3JlIiwiZW5oYW5jZWRGYWN0b3J5IiwiZ2V0U3RhdGUiLCJnZXRBbGwiLCJuZXdGYWN0b3JpZXMiLCJwcmV2IiwiSW5qZWN0b3IiLCJpbmplY3RvciIsIlByb3BUeXBlcyIsInNoYXBlIiwiZnVuYyIsInN0cmluZyIsInZhbGlkYXRlIiwicHJvdmlkZUluamVjdG9yIiwiSW5qZWN0YWJsZSIsImluamVjdG9yQ29udGFpbmVyIiwiSW5qZWN0b3JQcm92aWRlciIsImNvbXBvbmVudCIsImJpbmQiLCJwcm9wcyIsIkNvbXBvbmVudCIsImNoaWxkQ29udGV4dFR5cGVzIiwiaW5qZWN0b3JDb250ZXh0IiwicHJvdmlkZUNvbnRleHQiLCJDb250ZXh0dWFsQ29tcG9uZW50IiwiQ29udGV4dFByb3ZpZGVyIiwiY29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJ3aXRoSW5qZWN0b3IiLCJkZWZhdWx0Q29udGV4dCIsImluamVjdCIsImRlcGVuZGVuY2llcyIsIm1hcERlcGVuZGVuY2llc1RvUHJvcHMiLCJnZXRDb250ZXh0IiwiSW5qZWN0aW5nQ29tcG9uZW50IiwiZGVwcyIsInN0YXRlIiwibmV4dFByb3BzIiwibmV4dENvbnRleHQiLCJuZXdDb250ZXh0Iiwic2V0U3RhdGUiLCJyZXNvbHZlZCIsImRlcCIsIm5ld1Byb3BzIiwiTm90Rm91bmRDb21wb25lbnQiLCJpdGVtTmFtZSIsImNsYXNzbmFtZXMiLCJwcm9wVHlwZXMiLCJpc1JlcXVpcmVkIiwiYW55IiwibG9hZENvbXBvbmVudCIsInRhcmdldE5hbWUiLCJvdmVycmlkZUluamVjdG9yIiwiTGVnYWN5TG9hZGVyIiwidGFyZ2V0IiwiZXJyb3IiLCJlIiwiVGFyZ2V0IiwiTm90Rm91bmQiLCJjb250ZXh0SW5qZWN0b3IiLCJDb250YWluZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQU1BLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBeUI7QUFBQSxTQUFPO0FBQ3BDOzs7O0FBSUFDLFlBQVEsRUFBRSxFQUwwQjs7QUFPcEM7Ozs7QUFJQUMsZUFBVyxFQUFFLEtBWHVCO0FBYXBDQyxhQUFTLEVBQUUsRUFieUI7O0FBZXBDOzs7Ozs7O0FBT0FDLFlBdEJvQyxvQkFzQjNCQyxHQXRCMkIsRUFzQnRCQyxLQXRCc0IsRUFzQkM7QUFBQSxxRkFBSixFQUFJO0FBQUEsVUFBZEMsS0FBYyxRQUFkQSxLQUFjOztBQUNuQyxVQUFJLEtBQUtMLFdBQVQsRUFBc0I7QUFDcEIsY0FBTSxJQUFJTSxLQUFKLENBQVUsMERBQVYsQ0FBTjtBQUNEOztBQUNELFVBQUksS0FBS1AsUUFBTCxDQUFjSSxHQUFkLEtBQXNCRSxLQUFLLEtBQUssSUFBcEMsRUFBMEM7QUFDeEMsY0FBTSxJQUFJQyxLQUFKLDZDQUNzQkgsR0FEdEIsMlBBQU47QUFLRDs7QUFFRCxVQUFJLE9BQU8sS0FBS0EsR0FBTCxDQUFQLEtBQXFCLFdBQXJCLElBQW9DLENBQUMsS0FBS0osUUFBTCxDQUFjSSxHQUFkLENBQXpDLEVBQTZEO0FBQzNELGNBQU0sSUFBSUcsS0FBSiw2Q0FDc0JILEdBRHRCLG1KQUFOO0FBSUQ7O0FBRUQsVUFBTUksZUFBZSxHQUFHLENBQUMsTUFBRCxFQUFTLG1CQUFULEVBQThCLEtBQTlCLEVBQXFDLFVBQXJDLENBQXhCOztBQUNBLFVBQUksQ0FBQ0EsZUFBZSxDQUFDQyxLQUFoQixDQUFzQixVQUFBQyxNQUFNO0FBQUEsZUFBSSxPQUFPTCxLQUFLLENBQUNLLE1BQUQsQ0FBWixLQUF5QixVQUE3QjtBQUFBLE9BQTVCLENBQUwsRUFBMkU7QUFDekUsY0FBTSxJQUFJSCxLQUFKLDZDQUNzQkgsR0FEdEIsbUhBRWtDSSxlQUFlLENBQUNHLElBQWhCLENBQXFCLElBQXJCLENBRmxDLGNBQU47QUFJRDs7QUFFRCxXQUFLWCxRQUFMLENBQWNJLEdBQWQsSUFBcUJDLEtBQXJCLENBM0JtQyxDQTZCbkM7O0FBQ0EsV0FBS0QsR0FBTCxJQUFZQyxLQUFaO0FBQ0QsS0FyRG1DOztBQXVEcEM7OztBQUdBTyxRQTFEb0Msa0JBMEQ3QjtBQUNMLFVBQUksS0FBS1gsV0FBVCxFQUFzQjtBQUNwQixjQUFNLElBQUlNLEtBQUosQ0FBVSwwREFBVixDQUFOO0FBQ0Q7O0FBQ0RNLFlBQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUtkLFFBQW5CLEVBQ0dlLE9BREgsQ0FDVyxVQUFBQyxPQUFPO0FBQUEsZUFBSUEsT0FBTyxDQUFDSixJQUFSLEVBQUo7QUFBQSxPQURsQjtBQUdBLFdBQUtYLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxXQUFLQyxTQUFMLENBQWVhLE9BQWYsQ0FBdUIsVUFBQ0UsUUFBRCxFQUFjO0FBQ25DQSxnQkFBUTtBQUNULE9BRkQ7QUFHQSxXQUFLZixTQUFMLEdBQWlCLEVBQWpCO0FBQ0QsS0F0RW1DOztBQXdFcEM7Ozs7Ozs7O0FBUUFnQixhQWhGb0MscUJBZ0YxQkMsSUFoRjBCLEVBZ0ZwQkYsUUFoRm9CLEVBZ0ZPO0FBQUEsVUFBakJHLFVBQWlCLHVFQUFKLEVBQUk7O0FBQ3pDLFVBQUksS0FBS25CLFdBQVQsRUFBc0I7QUFDcEIsY0FBTSxJQUFJTSxLQUFKLENBQVUsMERBQVYsQ0FBTjtBQUNEOztBQUVELFVBQU1jLE9BQU8sR0FBR1IsTUFBTSxDQUFDUyxPQUFQLENBQWUsS0FBS3RCLFFBQXBCLEVBQThCdUIsTUFBOUIsQ0FDZCxVQUFDQyxlQUFEO0FBQUE7QUFBQSxZQUFtQkMsV0FBbkI7QUFBQSxZQUFnQ1QsT0FBaEM7O0FBQUEsaUNBQ0tRLGVBREwsc0JBRUdDLFdBRkgsRUFFaUJULE9BQU8sQ0FBQ1UsaUJBQVIsQ0FBMEJQLElBQTFCLEVBQWdDQyxVQUFoQyxDQUZqQjtBQUFBLE9BRGMsRUFLZCxFQUxjLENBQWhCO0FBT0FILGNBQVEsQ0FBQ0ksT0FBRCxDQUFSO0FBQ0QsS0E3Rm1DO0FBK0ZwQ00sU0EvRm9DLGlCQStGOUJWLFFBL0Y4QixFQStGcEI7QUFDZCxVQUFJLE9BQU9BLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsY0FBTSxJQUFJVixLQUFKLENBQVUscUNBQVYsQ0FBTjtBQUNEOztBQUNELFVBQUksS0FBS04sV0FBVCxFQUFzQjtBQUNwQmdCLGdCQUFRO0FBQ1I7QUFDRDs7QUFFRCxXQUFLZixTQUFMLGdDQUNLLEtBQUtBLFNBRFYsSUFFRWUsUUFGRjtBQUlEO0FBNUdtQyxHQUFQO0FBQUEsQ0FBL0I7O0FBK0dlbEIsc0dBQWYsRTs7Ozs7Ozs7Ozs7Ozs7OztBQy9HQTtBQUVBOzs7O0FBR0EsSUFBTTZCLE1BQU0sR0FBRyxRQUFmO0FBRUE7Ozs7QUFHQSxJQUFNQyxLQUFLLEdBQUcsT0FBZDtBQUVBOzs7O0FBR0EsSUFBTUMsVUFBVSxHQUFHLFVBQW5CO0FBRUE7Ozs7QUFHQSxJQUFNQyxVQUFVLEdBQUcsVUFBbkI7QUFFQTs7Ozs7QUFJQSxJQUFNQyxVQUFVLEdBQUcsQ0FBQ0osTUFBRCxFQUFTQyxLQUFULENBQW5CO0FBRUE7Ozs7O0FBSUEsSUFBTUksY0FBYyxHQUFHLFlBQXZCO0FBRUE7Ozs7O0FBSUEsSUFBTUMsUUFBUSxHQUFHLEdBQWpCO0FBRUE7Ozs7O0FBSUEsSUFBTUMsWUFBWSxHQUFHLFNBQWZBLFlBQWUsQ0FBQ0MsSUFBRCxFQUFVO0FBQzdCSixZQUFVLENBQUNqQixPQUFYLENBQW1CLFVBQUFzQixDQUFDLEVBQUk7QUFDdEIsUUFDRSxPQUFPRCxJQUFJLENBQUNDLENBQUQsQ0FBWCxLQUFtQixXQUFuQixJQUNDLE9BQU9ELElBQUksQ0FBQ0MsQ0FBRCxDQUFYLEtBQW1CLFFBQW5CLElBQStCLENBQUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxJQUFJLENBQUNDLENBQUQsQ0FBbEIsQ0FGbkMsRUFHRTtBQUNBLFlBQU0sSUFBSTlCLEtBQUosMEJBQTRCOEIsQ0FBNUIsZ0NBQU47QUFDRDtBQUNGLEdBUEQ7QUFRRCxDQVREO0FBV0E7Ozs7Ozs7Ozs7Ozs7O0FBWUEsSUFBTUcsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxVQUFELEVBQWdCO0FBQ3BDLE1BQUlDLFFBQVEsR0FBRyxJQUFmO0FBQ0FWLFlBQVUsQ0FBQ2pCLE9BQVgsQ0FBbUIsVUFBQTRCLFFBQVEsRUFBSTtBQUM3QixRQUFJRixVQUFVLENBQUNFLFFBQUQsQ0FBVixDQUFxQkMsUUFBckIsQ0FBOEJWLFFBQTlCLENBQUosRUFBNkM7QUFDM0MsVUFBSU8sVUFBVSxDQUFDRSxRQUFELENBQVYsQ0FBcUJFLE1BQXJCLEdBQThCLENBQWxDLEVBQXFDO0FBQ25DLGNBQU0sSUFBSXRDLEtBQUosMkJBQ0VvQyxRQURGLGlCQUNpQkYsVUFBVSxDQUFDdEIsSUFENUIscUVBRVllLFFBRlosMkJBQU47QUFJRCxPQUxELE1BS08sSUFBSVEsUUFBSixFQUFjO0FBQ25CLGNBQU0sSUFBSW5DLEtBQUosd0NBQ2VvQyxRQURmLHNCQUNtQ0YsVUFBVSxDQUFDdEIsSUFEOUMsNkRBQU47QUFJRCxPQUxNLE1BS0E7QUFDTHVCLGdCQUFRLEdBQUdDLFFBQVg7QUFDRDtBQUNGO0FBQ0YsR0FoQkQ7QUFrQkEsU0FBT0QsUUFBUDtBQUNELENBckJEO0FBdUJBOzs7Ozs7O0lBS01JLHFDOzs7QUFDSjs7O0FBR0EsZ0NBQWM7QUFBQTs7QUFDWixTQUFLQyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixFQUFyQjtBQUNEO0FBRUQ7Ozs7Ozs7OzJCQUlPO0FBQUE7O0FBQ0w7O0FBRUEsVUFBTUMsVUFBVSxHQUFHLENBQUNuQixVQUFELEVBQWFDLFVBQWIsQ0FBbkI7QUFDQSxVQUFNbUIsS0FBSyxHQUFHLENBQUNELFVBQUQsQ0FBZDtBQUNBLFVBQUlFLGlCQUFpQixHQUFHLEVBQXhCOztBQUNBLFdBQUtKLFlBQUwsQ0FBa0JoQyxPQUFsQixDQUEwQixVQUFBMEIsVUFBVSxFQUFJO0FBQUEsWUFDOUJ0QixJQUQ4QixHQUNyQnNCLFVBRHFCLENBQzlCdEIsSUFEOEI7QUFFdEMsWUFBTXVCLFFBQVEsR0FBR0YsYUFBYSxDQUFDQyxVQUFELENBQTlCOztBQUNBLFlBQUlDLFFBQVEsS0FBS2IsS0FBakIsRUFBd0I7QUFDdEJxQixlQUFLLENBQUNFLElBQU4sQ0FBVyxDQUFDckIsVUFBRCxFQUFhWixJQUFiLENBQVg7QUFDRCxTQUZELE1BRU8sSUFBSXVCLFFBQVEsS0FBS2QsTUFBakIsRUFBeUI7QUFDOUJzQixlQUFLLENBQUNFLElBQU4sQ0FBVyxDQUFDakMsSUFBRCxFQUFPVyxVQUFQLENBQVg7QUFDRCxTQUZNLE1BRUE7QUFDTDtBQUNBO0FBQ0FvQixlQUFLLENBQUNFLElBQU4sQ0FBVyxDQUFDakMsSUFBRCxFQUFPWSxVQUFQLENBQVg7QUFDQW1CLGVBQUssQ0FBQ0UsSUFBTixDQUFXLENBQUN0QixVQUFELEVBQWFYLElBQWIsQ0FBWDtBQUVBc0Isb0JBQVUsQ0FBQ2IsTUFBRCxDQUFWLENBQW1CYixPQUFuQixDQUEyQixVQUFBc0MsV0FBVyxFQUFJO0FBQ3hDSCxpQkFBSyxDQUFDRSxJQUFOLENBQVcsQ0FBQ2pDLElBQUQsRUFBT2tDLFdBQVAsQ0FBWDtBQUNELFdBRkQ7QUFHQVosb0JBQVUsQ0FBQ1osS0FBRCxDQUFWLENBQWtCZCxPQUFsQixDQUEwQixVQUFBdUMsVUFBVSxFQUFJO0FBQ3RDSixpQkFBSyxDQUFDRSxJQUFOLENBQVcsQ0FBQ0UsVUFBRCxFQUFhbkMsSUFBYixDQUFYO0FBQ0QsV0FGRDtBQUdEO0FBQ0YsT0FwQkQsRUFOSyxDQTJCTDs7O0FBQ0FvQyx3QkFBUSxDQUFDTCxLQUFELENBQVIsQ0FDR00sTUFESCxDQUNVLFVBQUFDLElBQUk7QUFBQSxlQUFJLENBQUNSLFVBQVUsQ0FBQ0wsUUFBWCxDQUFvQmEsSUFBcEIsQ0FBTDtBQUFBLE9BRGQsRUFFRzFDLE9BRkgsQ0FFVyxVQUFBSSxJQUFJLEVBQUk7QUFDZmdDLHlCQUFpQixHQUFHQSxpQkFBaUIsQ0FBQ08sTUFBbEIsQ0FDbEIsS0FBSSxDQUFDWCxZQUFMLENBQWtCUyxNQUFsQixDQUF5QixVQUFBRyxDQUFDO0FBQUEsaUJBQUlBLENBQUMsQ0FBQ3hDLElBQUYsS0FBV0EsSUFBZjtBQUFBLFNBQTFCLENBRGtCLENBQXBCO0FBR0QsT0FOSDtBQVFBLFdBQUs0QixZQUFMLEdBQW9CSSxpQkFBcEI7QUFFQSxhQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7d0JBTUlmLEksRUFBTXdCLE8sRUFBU0MsVyxFQUFhO0FBQzlCMUIsa0JBQVksQ0FBQ0MsSUFBRCxDQUFaLENBRDhCLENBRzlCOztBQUNBLFdBQUtZLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxVQUFJYyxPQUFPLEdBQUdELFdBQWQ7O0FBQ0EsVUFBSSxDQUFDQyxPQUFELElBQVksQ0FBQ0EsT0FBTyxDQUFDakIsTUFBekIsRUFBaUM7QUFDL0JpQixlQUFPLEdBQUcsQ0FBQzdCLGNBQUQsQ0FBVjtBQUNELE9BRkQsTUFFTyxJQUFJLENBQUNLLEtBQUssQ0FBQ0MsT0FBTixDQUFjdUIsT0FBZCxDQUFMLEVBQTZCO0FBQ2xDQSxlQUFPLEdBQUcsQ0FBQ0EsT0FBRCxDQUFWO0FBQ0Q7O0FBRUQsVUFBTUMsVUFBVSxHQUFHLG9DQUFLM0IsSUFBUjtBQUFjd0IsZUFBTyxFQUFQQSxPQUFkO0FBQXVCRSxlQUFPLEVBQVBBO0FBQXZCLFFBQWhCLENBWjhCLENBYTlCOzs7QUFDQTlCLGdCQUFVLENBQUNqQixPQUFYLENBQW1CLFVBQUFzQixDQUFDLEVBQUk7QUFDdEIsWUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsSUFBSSxDQUFDQyxDQUFELENBQWxCLENBQUwsRUFBNkI7QUFDM0IwQixvQkFBVSxDQUFDMUIsQ0FBRCxDQUFWLEdBQWdCRCxJQUFJLENBQUNDLENBQUQsQ0FBSixHQUFVLENBQUNELElBQUksQ0FBQ0MsQ0FBRCxDQUFMLENBQVYsR0FBc0IsRUFBdEM7QUFDRCxTQUZELE1BRU87QUFDTDBCLG9CQUFVLENBQUMxQixDQUFELENBQVYsR0FBZ0JELElBQUksQ0FBQ0MsQ0FBRCxDQUFwQjtBQUNEO0FBQ0YsT0FORCxFQWQ4QixDQXFCOUI7O0FBQ0EsVUFBSUwsVUFBVSxDQUFDdkIsS0FBWCxDQUFpQixVQUFBdUQsQ0FBQztBQUFBLGVBQUksQ0FBQ0QsVUFBVSxDQUFDQyxDQUFELENBQVYsQ0FBY25CLE1BQW5CO0FBQUEsT0FBbEIsQ0FBSixFQUFrRDtBQUNoRGtCLGtCQUFVLENBQUNsQyxLQUFELENBQVYsR0FBb0IsQ0FBQ0MsVUFBRCxDQUFwQjtBQUNBaUMsa0JBQVUsQ0FBQ25DLE1BQUQsQ0FBVixHQUFxQixDQUFDRyxVQUFELENBQXJCO0FBQ0Q7O0FBRUQsV0FBS2dCLFlBQUwsQ0FBa0JLLElBQWxCLENBQXVCVyxVQUF2Qjs7QUFFQSxhQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7OzsyQ0FLK0M7QUFBQSxVQUExQkQsT0FBMEIsdUVBQWhCN0IsY0FBZ0I7O0FBQzdDLFVBQUksQ0FBQyxLQUFLZSxhQUFMLENBQW1CYyxPQUFuQixDQUFMLEVBQWtDO0FBQ2hDLFlBQU1HLGdCQUFnQixHQUFHSCxPQUFPLENBQUNJLEtBQVIsQ0FBYyxHQUFkLENBQXpCO0FBQ0EsYUFBS2xCLGFBQUwsQ0FBbUJjLE9BQW5CLElBQThCLEtBQUtmLFlBQUwsQ0FBa0JTLE1BQWxCLENBQXlCLFVBQUFmLFVBQVU7QUFBQSxpQkFDL0RBLFVBQVUsQ0FBQ3FCLE9BQVgsQ0FBbUIsQ0FBbkIsTUFBMEI3QixjQUExQixJQUNBUSxVQUFVLENBQUNxQixPQUFYLENBQW1CckQsS0FBbkIsQ0FBeUIsVUFBQzBELElBQUQsRUFBT0MsS0FBUDtBQUFBLG1CQUN2QkQsSUFBSSxLQUFLakMsUUFBVCxJQUFxQitCLGdCQUFnQixDQUFDRyxLQUFELENBQWhCLEtBQTRCRCxJQUQxQjtBQUFBLFdBQXpCLENBRitEO0FBQUEsU0FBbkMsQ0FBOUI7QUFNRDs7QUFDRCxhQUFPLEtBQUtuQixhQUFMLENBQW1CYyxPQUFuQixDQUFQO0FBQ0Q7Ozs7OztBQUdIO0FBRWVoQixpSEFBZixFOzs7OztBQ2hONkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTyxxQkFBWTtBQUN4QjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRLHFCQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWE7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7O0FBRUEsUUFBUSxLQUFxQyxFQUFFLEVBSTFDOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQyxFQUFFLEVBRTFDOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQyxFQUFFLHVCQU0xQzs7QUFFTDtBQUNBOztBQUVBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxvQkFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLGtCQUFhO0FBQ3RCLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxNQUFNLG9CQUFlO0FBQ3JCLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsa0JBQWEsR0FBRztBQUM3QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxLQUE2RyxFQUFFLEVBRWxIOztBQUUrSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM25CaEk7QUFDQTs7QUFFQSxJQUFNdUIscUNBQWtCLEdBQUcsU0FBckJBLGtCQUFxQjtBQUFBLFNBQU87QUFDaEM7Ozs7QUFJQUMsd0JBQW9CLEVBQUUsRUFMVTs7QUFPaEM7Ozs7QUFJQXRFLFlBQVEsRUFBRSxFQVhzQjs7QUFhaEM7Ozs7QUFJQXVFLGFBQVMsRUFBRSxFQWpCcUI7QUFtQmhDQyxnQkFBWSxFQUFFLEVBbkJrQjs7QUFxQmhDOzs7O0FBSUF2RSxlQUFXLEVBQUUsS0F6Qm1CO0FBMkJoQ3dFLGVBM0JnQyx5QkEyQmxCO0FBQ1osVUFBSSxLQUFLeEUsV0FBVCxFQUFzQjtBQUNwQixjQUFNLElBQUlNLEtBQUosQ0FBVSwwREFBVixDQUFOO0FBQ0Q7QUFDRixLQS9CK0I7O0FBaUNoQzs7Ozs7O0FBTUFtRSxPQXZDZ0MsZUF1QzVCdEUsR0F2QzRCLEVBdUN2QjBELE9BdkN1QixFQXVDZDtBQUNoQixVQUFJLENBQUMsS0FBSzdELFdBQVYsRUFBdUI7QUFDckIsY0FBTSxJQUFJTSxLQUFKLG9JQUFOO0FBSUQ7O0FBQ0QsVUFBTXFELE9BQU8sR0FBRyxLQUFLVyxTQUFMLENBQWVuRSxHQUFmLENBQWhCOztBQUNBLFVBQUksQ0FBQ3dELE9BQUwsRUFBYztBQUNaLGNBQU0sSUFBSXJELEtBQUoscUNBQXVDSCxHQUF2QyxxQkFBTjtBQUNEOztBQUVELGFBQU93RCxPQUFPLENBQUNFLE9BQUQsQ0FBZDtBQUNELEtBcEQrQjs7QUFzRGhDOzs7Ozs7OztBQVFBYSxhQTlEZ0MscUJBOER0QnZDLElBOURzQixFQThEaEJoQyxHQTlEZ0IsRUE4RFh3RCxPQTlEVyxFQThERjtBQUM1QixXQUFLYSxXQUFMOztBQUQ0Qix1QkFHTXJFLEdBQUcsQ0FBQzhELEtBQUosQ0FBVSxHQUFWLENBSE47QUFBQTtBQUFBLFVBR3JCekMsV0FIcUI7QUFBQSxVQUdMcUMsT0FISzs7QUFJNUIsVUFBSWMsUUFBUSxHQUFHLEtBQUtOLG9CQUFMLENBQTBCN0MsV0FBMUIsQ0FBZjs7QUFDQSxVQUFJLENBQUNtRCxRQUFMLEVBQWU7QUFDYkEsZ0JBQVEsR0FBRyxJQUFJOUIsdUNBQUosRUFBWDtBQUNBLGFBQUt3QixvQkFBTCx1Q0FDSyxLQUFLQSxvQkFEVix3Q0FFRzdDLFdBRkgsRUFFaUJtRCxRQUZqQjtBQUlEOztBQUNEQSxjQUFRLENBQUNDLEdBQVQsQ0FDRXpDLElBREYsRUFFRXdCLE9BRkYsRUFHRUUsT0FIRjtBQUtELEtBL0UrQjs7QUFpRmhDOzs7QUFHQWxELFFBcEZnQyxrQkFvRnpCO0FBQUE7O0FBQ0wsV0FBSzZELFdBQUw7QUFDQSxXQUFLRixTQUFMLEdBQWlCMUQsTUFBTSxDQUFDaUUsSUFBUCxDQUFZLEtBQUs5RSxRQUFqQixFQUNkdUIsTUFEYyxDQUNQLFVBQUNnRCxTQUFELEVBQVluRSxHQUFaLEVBQW9CO0FBQzFCLFlBQU1xQyxVQUFVLEdBQUcsS0FBSSxDQUFDNkIsb0JBQUwsQ0FBMEJsRSxHQUExQixDQUFuQjs7QUFDQSxZQUFJcUMsVUFBSixFQUFnQjtBQUNkQSxvQkFBVSxDQUFDc0MsSUFBWDtBQUVBLHFEQUNLUixTQURMLHdDQUVHbkUsR0FGSCxFQUVTLFlBQThCO0FBQUEsZ0JBQTdCMEQsT0FBNkIsdUVBQW5CN0IsY0FBbUI7QUFDbkMsZ0JBQU0rQyxRQUFRLGFBQU01RSxHQUFOLGVBQWMwRCxPQUFkLENBQWQ7O0FBQ0EsZ0JBQUksQ0FBQyxLQUFJLENBQUNVLFlBQUwsQ0FBa0JRLFFBQWxCLENBQUwsRUFBa0M7QUFDaEMsa0JBQU1DLE9BQU8sR0FBR3hDLFVBQVUsQ0FBQ3lDLG9CQUFYLENBQWdDcEIsT0FBaEMsQ0FBaEI7QUFDQSxtQkFBSSxDQUFDVSxZQUFMLENBQWtCUSxRQUFsQixJQUE4QixLQUFJLENBQUNHLFVBQUwsQ0FBZ0IvRSxHQUFoQixFQUFxQjZFLE9BQXJCLENBQTlCO0FBQ0Q7O0FBRUQsbUJBQU8sS0FBSSxDQUFDVCxZQUFMLENBQWtCUSxRQUFsQixDQUFQO0FBQ0QsV0FWSDtBQVlEOztBQUNELG1EQUNLVCxTQURMLHdDQUVHbkUsR0FGSCxFQUVTO0FBQUEsaUJBQU0sS0FBSSxDQUFDK0UsVUFBTCxDQUFnQi9FLEdBQWhCLEVBQXFCLEVBQXJCLENBQU47QUFBQSxTQUZUO0FBSUQsT0F2QmMsRUF1QlosRUF2QlksQ0FBakI7QUF5QkEsV0FBS0gsV0FBTCxHQUFtQixJQUFuQjtBQUNELEtBaEgrQjs7QUFrSGhDOzs7Ozs7OztBQVFBRSxZQTFIZ0Msb0JBMEh2QkMsR0ExSHVCLEVBMEhsQkMsS0ExSGtCLEVBMEhLO0FBQUEscUZBQUosRUFBSTtBQUFBLFVBQWRDLEtBQWMsUUFBZEEsS0FBYzs7QUFDbkMsV0FBS21FLFdBQUw7O0FBRUEsVUFBSSxLQUFLekUsUUFBTCxDQUFjSSxHQUFkLEtBQXNCRSxLQUFLLEtBQUssSUFBcEMsRUFBMEM7QUFDeEMsY0FBTSxJQUFJQyxLQUFKLDhDQUN1QkgsR0FEdkIsNFBBQU47QUFLRDs7QUFDRCxXQUFLSixRQUFMLHVDQUNLLEtBQUtBLFFBRFYsd0NBRUdJLEdBRkgsRUFFU0MsS0FGVDtBQUlELEtBeEkrQjs7QUEwSWhDOzs7Ozs7O0FBT0ErRSxnQkFqSmdDLHdCQWlKbkJDLEdBakptQixFQWlKRTtBQUFBLHNGQUFKLEVBQUk7QUFBQSxVQUFkL0UsS0FBYyxTQUFkQSxLQUFjOztBQUNoQyxXQUFLbUUsV0FBTDtBQUVBLFVBQU1hLE9BQU8sR0FBR3pFLE1BQU0sQ0FBQ2lFLElBQVAsQ0FBWU8sR0FBWixDQUFoQjtBQUNBLFVBQU1FLFFBQVEsR0FBRzFFLE1BQU0sQ0FBQ2lFLElBQVAsQ0FBWSxLQUFLOUUsUUFBakIsRUFBMkJ3RCxNQUEzQixDQUFrQyxVQUFDeEMsT0FBRDtBQUFBLGVBQ2pEc0UsT0FBTyxDQUFDMUMsUUFBUixDQUFpQjVCLE9BQWpCLENBRGlEO0FBQUEsT0FBbEMsQ0FBakI7O0FBR0EsVUFBSXVFLFFBQVEsQ0FBQzFDLE1BQVQsSUFBbUJ2QyxLQUFLLEtBQUssSUFBakMsRUFBdUM7QUFDckMsWUFBTWtGLElBQUksR0FBR0QsUUFBUSxDQUFDNUUsSUFBVCxDQUFjLElBQWQsQ0FBYjtBQUVBLGNBQU0sSUFBSUosS0FBSiwrQ0FDd0JpRixJQUR4Qiw0UEFBTjtBQUtEOztBQUNELFdBQUt4RixRQUFMLHVDQUNLLEtBQUtBLFFBRFYsRUFFS3FGLEdBRkw7QUFJRCxLQXJLK0I7O0FBdUtoQzs7Ozs7Ozs7Ozs7O0FBWUFuRSxhQW5MZ0MscUJBbUx0QkMsSUFuTHNCLEVBbUxoQkYsUUFuTGdCLEVBbUxXO0FBQUEsVUFBakJHLFVBQWlCLHVFQUFKLEVBQUk7QUFDekMsV0FBS3FELFdBQUw7QUFFQXhELGNBQVEsQ0FBQyxLQUFLUyxpQkFBTCxDQUF1QlAsSUFBdkIsRUFBNkJDLFVBQTdCLENBQUQsQ0FBUjtBQUNELEtBdkwrQjs7QUF5TGhDOzs7Ozs7QUFNQU0scUJBL0xnQyw2QkErTGRQLElBL0xjLEVBK0xSQyxVQS9MUSxFQStMSTtBQUFBOztBQUNsQyxhQUFPLFVBQUNoQixHQUFELEVBQU1xRixPQUFOLEVBQWtCO0FBQ3ZCLGNBQUksQ0FBQ2QsU0FBTDtBQUFpQnhELGNBQUksRUFBSkE7QUFBakIsV0FBMEJDLFVBQTFCLEdBQXdDaEIsR0FBeEMsRUFBNkNxRixPQUE3QztBQUNELE9BRkQ7QUFHRCxLQW5NK0I7O0FBcU1oQzs7Ozs7O0FBTUFOLGNBM01nQyxzQkEyTXJCL0UsR0EzTXFCLEVBMk1oQnNGLGlCQTNNZ0IsRUEyTUc7QUFDakMsVUFBTTFFLE9BQU8sR0FBRyxLQUFLaEIsUUFBTCxDQUFjSSxHQUFkLENBQWhCO0FBQ0EsVUFBTXVGLFdBQVcsR0FBR0QsaUJBQWlCLENBQUNMLEdBQWxCLENBQXNCLFVBQUExQixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDQyxPQUFOO0FBQUEsT0FBdkIsQ0FBcEI7QUFDQSxhQUFPZ0MsT0FBTyxNQUFQLDhDQUFXRCxXQUFYLEdBQXdCM0UsT0FBeEIsQ0FBUDtBQUNEO0FBL00rQixHQUFQO0FBQUEsQ0FBM0I7O0FBa05lcUQsaUhBQWYsRTs7Ozs7Ozs7Ozs7Ozs7QUNyTkE7QUFFQTs7Ozs7Ozs7QUFPQSxJQUFNd0IsaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQixDQUFDQyxRQUFELEVBQVdDLFVBQVgsRUFBMEI7QUFDbEQsTUFBTUMsYUFBYSxHQUFJRixRQUFRLENBQUNHLFdBQVQsSUFBd0JILFFBQVEsQ0FBQzNFLElBQWpDLElBQXlDLFdBQWhFO0FBQ0EsTUFBTStFLEtBQUssSUFBSUYsYUFBSixtREFBc0JELFVBQXRCLEVBQVg7QUFFQSxTQUFPRyxLQUFLLENBQUMzRSxNQUFOLENBQWEsVUFBQzRFLEdBQUQsRUFBTUMsSUFBTjtBQUFBLHFCQUFrQkEsSUFBbEIsY0FBMEJELEdBQTFCO0FBQUEsR0FBYixDQUFQO0FBQ0QsQ0FMRDs7QUFPQSxJQUFNRSwrQ0FBdUIsR0FBRyxTQUExQkEsdUJBQTBCO0FBQUEsTUFBQ0MsSUFBRCx1RUFBUWpDLHVDQUFrQixFQUExQjtBQUFBLGtEQUMzQmlDLElBRDJCO0FBRzlCOzs7Ozs7OztBQVFBNUIsT0FYOEIsZUFXMUJ0RSxHQVgwQixFQVdyQjBELE9BWHFCLEVBV0g7QUFBQTs7QUFBQSx3Q0FBTnlDLElBQU07QUFBTkEsWUFBTTtBQUFBOztBQUN6QixVQUFNdkYsT0FBTyxHQUFHLGFBQUFzRixJQUFJLENBQUM1QixHQUFMLEVBQVM4QixJQUFULG1CQUFjLElBQWQsRUFBb0JwRyxHQUFwQixFQUF5QjBELE9BQXpCLFNBQXFDeUMsSUFBckMsRUFBaEI7O0FBRUEsVUFBSXZGLE9BQU8sQ0FBQ2lGLFdBQVIsSUFBdUJqRixPQUFPLENBQUNpRixXQUFSLENBQW9CUSxLQUFwQixDQUEwQixLQUExQixDQUEzQixFQUE2RDtBQUMzRCxlQUFPekYsT0FBUDtBQUNEOztBQUVELFVBQU1nRixhQUFhLEdBQUloRixPQUFPLENBQUNpRixXQUFSLElBQXVCakYsT0FBTyxDQUFDRyxJQUEvQixJQUF1QyxXQUE5RDtBQUNBLFVBQU11RixZQUFZLEdBQUk1QyxPQUFELGNBQWdCQSxPQUFoQixTQUE2QixFQUFsRCxDQVJ5QixDQVN6Qjs7QUFDQTlDLGFBQU8sQ0FBQ2lGLFdBQVIsYUFBeUJELGFBQXpCLFNBQXlDVSxZQUF6QztBQUVBLGFBQU8xRixPQUFQO0FBQ0QsS0F4QjZCOztBQTBCOUI7Ozs7OztBQU1BVSxxQkFoQzhCLDZCQWdDWlAsSUFoQ1ksRUFnQ05DLFVBaENNLEVBZ0NNO0FBQUE7O0FBQ2xDLGFBQU8sVUFBQ2hCLEdBQUQsRUFBTXFGLE9BQU4sRUFBZVEsV0FBZixFQUErQjtBQUNwQyxhQUFJLENBQUN0QixTQUFMO0FBQWlCeEQsY0FBSSxFQUFKQTtBQUFqQixXQUEwQkMsVUFBMUI7QUFBc0M2RSxxQkFBVyxFQUFYQTtBQUF0QyxZQUFxRDdGLEdBQXJELEVBQTBEcUYsT0FBMUQ7QUFDRCxPQUZEO0FBR0QsS0FwQzZCOztBQXNDOUI7Ozs7OztBQU1BTixjQTVDOEIsc0JBNENuQi9FLEdBNUNtQixFQTRDZHNGLGlCQTVDYyxFQTRDSztBQUNqQyxVQUFNOUIsT0FBTyxHQUFHMEMsSUFBSSxDQUFDbkIsVUFBTCxDQUFnQnFCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCcEcsR0FBM0IsRUFBZ0NzRixpQkFBaEMsQ0FBaEI7QUFDQSxVQUFNUSxLQUFLLEdBQUdSLGlCQUFpQixDQUFDTCxHQUFsQixDQUFzQixVQUFBNUMsVUFBVTtBQUFBLGVBQUlBLFVBQVUsQ0FBQ3dELFdBQVgsSUFBMEJ4RCxVQUFVLENBQUN0QixJQUF6QztBQUFBLE9BQWhDLENBQWQ7QUFDQXlDLGFBQU8sQ0FBQ3FDLFdBQVIsR0FBc0JKLGlCQUFpQixDQUFDLEtBQUs3RixRQUFMLENBQWNJLEdBQWQsQ0FBRCxFQUFxQjhGLEtBQXJCLENBQXZDO0FBRUEsYUFBT3RDLE9BQVA7QUFDRDtBQWxENkI7QUFBQSxDQUFoQzs7QUFzRGV5QyxnSUFBZixFOzs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBOztBQUVBLElBQU1NLDJDQUFxQixHQUFHLFNBQXhCQSxxQkFBd0I7QUFBQSxNQUFDTCxJQUFELHVFQUFRakMsdUNBQWtCLEVBQTFCO0FBQUEsZ0RBQ3pCaUMsSUFEeUI7QUFHNUI7Ozs7QUFJQU0sU0FBSyxFQUFFLElBUHFCO0FBUzVCQyxZQVQ0QixvQkFTbkJELEtBVG1CLEVBU1o7QUFDZCxXQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDRCxLQVgyQjs7QUFhNUI7Ozs7Ozs7Ozs7QUFVQWpDLGFBdkI0QixxQkF1QmxCdkMsSUF2QmtCLEVBdUJaaEMsR0F2QlksRUF1QlB3RCxPQXZCTyxFQXVCRTtBQUFBOztBQUM1QixXQUFLYSxXQUFMO0FBRUEsVUFBSUcsUUFBUSxHQUFHLEtBQUtOLG9CQUFMLENBQTBCbEUsR0FBMUIsQ0FBZjs7QUFDQSxVQUFJLENBQUN3RSxRQUFMLEVBQWU7QUFDYkEsZ0JBQVEsR0FBRyxJQUFJOUIsdUNBQUosRUFBWDtBQUNBLGFBQUt3QixvQkFBTCwwQ0FDSyxLQUFLQSxvQkFEViwyQ0FFR2xFLEdBRkgsRUFFU3dFLFFBRlQ7QUFJRDs7QUFDRCxVQUFNa0MsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDOUYsT0FBRCxFQUFhO0FBQ25DLFlBQU0rRixRQUFRLEdBQUcsS0FBSSxDQUFDSCxLQUFMLElBQWMsS0FBSSxDQUFDQSxLQUFMLENBQVdHLFFBQTFDO0FBRUEsZUFBT25ELE9BQU8sQ0FBQzVDLE9BQUQsQ0FBUCxDQUFpQitGLFFBQWpCLENBQVA7QUFDRCxPQUpEOztBQUtBbkMsY0FBUSxDQUFDQyxHQUFULENBQ0V6QyxJQURGLEVBRUUwRSxlQUZGO0FBSUQsS0EzQzJCO0FBNkM1QkUsVUE3QzRCLG9CQTZDbkI7QUFDUCxVQUFNQyxZQUFZLEdBQUksS0FBS2hILFdBQU4sR0FDakJZLE1BQU0sQ0FBQ1MsT0FBUCxDQUFlLEtBQUtpRCxTQUFwQixFQUErQmhELE1BQS9CLENBQXNDLFVBQUMyRixJQUFEO0FBQUE7QUFBQSxZQUFROUcsR0FBUjtBQUFBLFlBQWF3RCxPQUFiOztBQUFBLHNEQUNuQ3NELElBRG1DLDJDQUVyQzlHLEdBRnFDLEVBRS9Cd0QsT0FBTyxFQUZ3QjtBQUFBLE9BQXRDLEVBR0UsRUFIRixDQURpQixDQUtuQjtBQUxtQixRQU1qQi9DLE1BQU0sQ0FBQ1MsT0FBUCxDQUFlLEtBQUt0QixRQUFwQixFQUE4QnVCLE1BQTlCLENBQXFDLFVBQUMyRixJQUFEO0FBQUE7QUFBQSxZQUFROUcsR0FBUjtBQUFBLFlBQWFZLE9BQWI7O0FBQUEsc0RBQ2xDa0csSUFEa0MsMkNBRXBDOUcsR0FGb0MsRUFFOUJZLE9BRjhCO0FBQUEsT0FBckMsRUFHRSxFQUhGLENBTko7QUFXQSxhQUFPaUcsWUFBUDtBQUNEO0FBMUQyQjtBQUFBLENBQTlCOztBQTZEZU4sMEhBQWYsRTs7QUNoRUE7QUFDQTtBQUNBO0FBRUEsSUFBTVEsa0JBQVEsR0FBR3BILDJDQUFzQixFQUF2QztBQUVBb0gsa0JBQVEsQ0FBQ2hILFFBQVQsQ0FBa0IsV0FBbEIsRUFBK0JrRyw0Q0FBdUIsRUFBdEQ7QUFDQWMsa0JBQVEsQ0FBQ2hILFFBQVQsQ0FBa0IsU0FBbEIsRUFBNkJ3RywwQ0FBcUIsRUFBbEQ7QUFFZVEsZ0VBQWYsRTs7Ozs7O0FDVEE7QUFFZTtBQUNiQyxVQUFRLEVBQUVDLG9CQUFTLENBQUNDLEtBQVYsQ0FBZ0I7QUFDeEI1QyxPQUFHLEVBQUUyQyxvQkFBUyxDQUFDRSxJQURTO0FBRXhCekQsV0FBTyxFQUFFdUQsb0JBQVMsQ0FBQ0csTUFGSztBQUd4QkMsWUFBUSxFQUFFSixvQkFBUyxDQUFDRTtBQUhJLEdBQWhCO0FBREcsQ0FBZixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTRyxlQUFULENBQXlCQyxVQUF6QixFQUFtRTtBQUFBLE1BQTlCQyxpQkFBOEIsdUVBQVZULFNBQVU7O0FBQUEsTUFDM0RVLGdCQUQyRDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdDQUU3QztBQUFBLFlBQ1JDLFNBRFEsR0FDTUYsaUJBRE4sQ0FDUkUsU0FEUTtBQUdoQixlQUFPO0FBQ0xWLGtCQUFRLEVBQUU7QUFDUjFDLGVBQUcsRUFBRW9ELFNBQVMsQ0FBQ3BELEdBQVYsQ0FBY3FELElBQWQsQ0FBbUJELFNBQW5CO0FBREc7QUFETCxTQUFQO0FBS0Q7QUFWOEQ7QUFBQTtBQUFBLCtCQVl0RDtBQUNQLGVBQU8sOEJBQUMsVUFBRCxFQUFnQixLQUFLRSxLQUFyQixDQUFQO0FBQ0Q7QUFkOEQ7O0FBQUE7QUFBQSxJQUNsQ0Msa0JBRGtDOztBQWlCakVKLGtCQUFnQixDQUFDSyxpQkFBakIsR0FBcUNDLGVBQXJDO0FBRUEsU0FBT04sZ0JBQVA7QUFDRDs7QUFFY0gsd0ZBQWYsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7O0FBRUEsSUFBTVUsNkJBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ3RFLE9BQUQ7QUFBQSxTQUFhLFVBQUN1RSxtQkFBRCxFQUF5QjtBQUFBLFFBQ3JEQyxlQURxRDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLDBDQUV2QztBQUNoQixpQkFBTztBQUNMbEIsb0JBQVEsRUFBRSxnQ0FDTCxLQUFLdEQsT0FBTCxDQUFhc0QsUUFEVjtBQUVOdEQscUJBQU8sRUFBUEE7QUFGTTtBQURILFdBQVA7QUFNRDtBQVR3RDtBQUFBO0FBQUEsaUNBV2hEO0FBQ1AsaUJBQU8sOEJBQUMsbUJBQUQsRUFBeUIsS0FBS2tFLEtBQTlCLENBQVA7QUFDRDtBQWJ3RDs7QUFBQTtBQUFBLE1BQzdCQyxrQkFENkI7O0FBZ0IzREssbUJBQWUsQ0FBQ0MsWUFBaEIsR0FBK0JDLGVBQS9CO0FBRUFGLG1CQUFlLENBQUNKLGlCQUFoQixHQUFvQ00sZUFBcEM7QUFFQSxXQUFPRixlQUFQO0FBQ0QsR0FyQnNCO0FBQUEsQ0FBdkI7O0FBdUJlRixxR0FBZixFOzs7Ozs7QUMxQkE7O0FBRUEsSUFBTUsseUJBQVksR0FBRyxTQUFmQSxZQUFlLENBQUNSLFNBQUQsRUFBZTtBQUNsQztBQUNBQSxXQUFTLENBQUNNLFlBQVYsaUNBQ01OLFNBQVMsQ0FBQ00sWUFBVixJQUEwQixFQURoQyxFQUVLSixlQUZMLEVBRmtDLENBTWxDOztBQUNBRixXQUFTLENBQUNoQyxXQUFWLGdDQUNLZ0MsU0FBUyxDQUFDaEMsV0FBVixJQUF5QmdDLFNBQVMsQ0FBQzlHLElBQW5DLElBQTJDLFdBRGhEO0FBSUEsU0FBTzhHLFNBQVA7QUFDRCxDQVpEOztBQWNlUSwrRkFBZixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBOztBQUVBLElBQU1DLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ1YsS0FBRCxFQUFRRyxlQUFSO0FBQUEsU0FBNEJBLGVBQTVCO0FBQUEsQ0FBdkI7QUFFQTs7Ozs7Ozs7OztBQVFBLElBQU1RLGFBQU0sR0FBRyxTQUFUQSxNQUFTLENBQUNDLFlBQUQsRUFBZUMsc0JBQWY7QUFBQSxNQUF1Q0MsVUFBdkMsdUVBQW9ESixjQUFwRDtBQUFBLFNBQ2IsVUFBQ0ssa0JBQUQsRUFBd0I7QUFDdEIsUUFBSUgsWUFBWSxJQUFJLENBQUN0RyxLQUFLLENBQUNDLE9BQU4sQ0FBY3FHLFlBQWQsQ0FBckIsRUFBa0Q7QUFDaEQsWUFBTSxJQUFJckksS0FBSixxRkFDOER5SSxJQUQ5RCwrQ0FDOERBLElBRDlELDhEQUFOO0FBSUQ7O0FBRUQsUUFBSUgsc0JBQXNCLElBQUksT0FBT0Esc0JBQVAsS0FBa0MsVUFBaEUsRUFBNEU7QUFDMUUsWUFBTSxJQUFJdEksS0FBSiwrTUFBTjtBQUlEOztBQUVELFFBQUksT0FBT3VJLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEMsWUFBTSxJQUFJdkksS0FBSiw2UEFBTjtBQUtELEtBckJxQixDQXVCdEI7OztBQXZCc0IsUUF3QmhCNEcsUUF4QmdCO0FBQUE7QUFBQTtBQUFBOztBQXlCcEIsd0JBQVlhLEtBQVosRUFBbUJsRSxPQUFuQixFQUE0QjtBQUFBOztBQUFBOztBQUMxQixrR0FBTWtFLEtBQU4sRUFBYWxFLE9BQWI7QUFFQSxjQUFLbUYsS0FBTCxHQUFhO0FBQ1huRixpQkFBTyxFQUFFZ0YsVUFBVSxDQUFDZCxLQUFELEVBQVFsRSxPQUFPLENBQUNzRCxRQUFSLENBQWlCdEQsT0FBekI7QUFEUixTQUFiO0FBSDBCO0FBTTNCOztBQS9CbUI7QUFBQTtBQUFBLDBDQWlDRjtBQUNoQixpQkFBTztBQUNMc0Qsb0JBQVEsRUFBRSx3QkFDTCxLQUFLdEQsT0FBTCxDQUFhc0QsUUFEVjtBQUVOdEQscUJBQU8sRUFBRSxLQUFLbUYsS0FBTCxDQUFXbkY7QUFGZDtBQURILFdBQVA7QUFNRDtBQXhDbUI7QUFBQTtBQUFBLGtEQTBDTW9GLFNBMUNOLEVBMENpQkMsV0ExQ2pCLEVBMEM4QjtBQUNoRCxjQUFNQyxVQUFVLEdBQUdOLFVBQVUsQ0FBQ0ksU0FBRCxFQUFZQyxXQUFXLENBQUMvQixRQUFaLENBQXFCdEQsT0FBakMsQ0FBN0I7O0FBRUEsY0FBSXNGLFVBQVUsS0FBSyxLQUFLSCxLQUFMLENBQVduRixPQUE5QixFQUF1QztBQUNyQyxpQkFBS3VGLFFBQUwsQ0FBYztBQUNadkYscUJBQU8sRUFBRXNGO0FBREcsYUFBZDtBQUdEO0FBQ0Y7QUFsRG1CO0FBQUE7QUFBQSxpQ0FvRFg7QUFBQTs7QUFDUCxjQUFJcEIsS0FBSyxHQUFHLEVBQVo7O0FBQ0EsY0FBSVksWUFBSixFQUFrQjtBQUFBLGdCQUNSbEUsR0FEUSxHQUNBLEtBQUtaLE9BQUwsQ0FBYXNELFFBRGIsQ0FDUjFDLEdBRFE7QUFFaEIsZ0JBQU00RSxRQUFRLEdBQUdWLFlBQVksQ0FBQ3ZELEdBQWIsQ0FBaUIsVUFBQWtFLEdBQUc7QUFBQSxxQkFBSTdFLEdBQUcsQ0FBQzZFLEdBQUQsRUFBTSxNQUFJLENBQUNOLEtBQUwsQ0FBV25GLE9BQWpCLENBQVA7QUFBQSxhQUFwQixDQUFqQjs7QUFFQSxnQkFBSStFLHNCQUFKLEVBQTRCO0FBQzFCYixtQkFBSyxHQUFHYSxzQkFBc0IsTUFBdEIsa0NBQTBCUyxRQUExQixFQUFSO0FBQ0QsYUFGRCxNQUVPO0FBQ0w7QUFDQVYsMEJBQVksQ0FBQzdILE9BQWIsQ0FBcUIsVUFBQ3dJLEdBQUQsRUFBTW5GLEtBQU4sRUFBZ0I7QUFDbkM0RCxxQkFBSyxDQUFDdUIsR0FBRCxDQUFMLEdBQWFELFFBQVEsQ0FBQ2xGLEtBQUQsQ0FBckI7QUFDRCxlQUZEO0FBR0Q7O0FBRUQsZ0JBQUksQ0FBQzRELEtBQUQsSUFBVSxjQUFPQSxLQUFQLE1BQWlCLFFBQS9CLEVBQXlDO0FBQ3ZDLG9CQUFNLElBQUl6SCxLQUFKLDBKQUFOO0FBSUQ7QUFDRjs7QUFDRCxjQUFNaUosUUFBUSxHQUFHLHdCQUNaeEIsS0FEUyxFQUVULEtBQUtBLEtBRkksQ0FBZDs7QUFJQSxpQkFBTyw4QkFBQyxrQkFBRCxFQUF3QndCLFFBQXhCLENBQVA7QUFDRDtBQS9FbUI7O0FBQUE7QUFBQSxNQXdCQ3ZCLGtCQXhCRDs7QUFrRnRCZCxZQUFRLENBQUNvQixZQUFULEdBQXdCQyxlQUF4QjtBQUVBckIsWUFBUSxDQUFDZSxpQkFBVCxHQUE2Qk0sZUFBN0I7QUFFQSxXQUFPckIsUUFBUDtBQUNELEdBeEZZO0FBQUEsQ0FBZjs7QUEyRmV3Qiw2RUFBZixFOzs7Ozs7QUN4R0E7QUFDQTtBQUNBOztBQUVBLElBQU1jLG1DQUFpQixHQUFHLFNBQXBCQSxpQkFBb0I7QUFBQSxNQUFHQyxRQUFILFFBQUdBLFFBQUg7QUFBQSxNQUFhdkksSUFBYixRQUFhQSxJQUFiO0FBQUEsTUFBbUJkLEtBQW5CLFFBQW1CQSxLQUFuQjtBQUFBLFNBQ3hCO0FBQUssYUFBUyxFQUFFc0osb0JBQVUsQ0FBQ0QsUUFBRCxFQUFXLHFCQUFYO0FBQTFCLEtBQ0UsdUVBREYsRUFJSXZJLElBQUksSUFBSSxPQUFPZCxLQUFQLEtBQWlCLFFBQTFCLEdBQ0c7QUFBTyxRQUFJLEVBQUMsUUFBWjtBQUFxQixRQUFJLEVBQUVjLElBQTNCO0FBQWlDLFNBQUssRUFBRWQ7QUFBeEMsSUFESCxHQUVHLElBTk4sQ0FEd0I7QUFBQSxDQUExQjs7QUFZQW9KLG1DQUFpQixDQUFDRyxTQUFsQixHQUE4QjtBQUM1QkYsVUFBUSxFQUFFckMsb0JBQVMsQ0FBQ0csTUFBVixDQUFpQnFDLFVBREM7QUFFNUIxSSxNQUFJLEVBQUVrRyxvQkFBUyxDQUFDRyxNQUZZO0FBRzVCbkgsT0FBSyxFQUFFZ0gsb0JBQVMsQ0FBQ3lDO0FBSFcsQ0FBOUI7QUFNZUwsc0hBQWYsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFhQSxJQUFNTSwyQkFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxVQUFELEVBQWdEO0FBQUEsTUFBbkNsRyxPQUFtQyx1RUFBekIsRUFBeUI7QUFBQSxNQUFyQm1HLGdCQUFxQjs7QUFBQSxNQUM5REMsWUFEOEQ7QUFBQTtBQUFBO0FBQUE7O0FBRWxFLDBCQUFZbEMsS0FBWixFQUFtQjtBQUFBOztBQUFBOztBQUNqQixrSEFBTUEsS0FBTjtBQUVBLFlBQUtpQixLQUFMLEdBQWE7QUFDWGtCLGNBQU0sRUFBRSxJQURHO0FBRVhDLGFBQUssRUFBRTtBQUZJLE9BQWI7QUFIaUI7QUFPbEI7O0FBVGlFO0FBQUE7QUFBQSx3Q0FXaEQ7QUFDaEIsWUFBTWpDLGVBQWUsR0FBR3JFLE9BQU8sSUFBSUEsT0FBTyxDQUFDQSxPQUEzQzs7QUFDQSxZQUFJLENBQUNxRSxlQUFMLEVBQXNCO0FBQ3BCLGlCQUFPLEtBQUtyRSxPQUFaO0FBQ0Q7O0FBQ0QsZUFBTztBQUNMc0Qsa0JBQVEsRUFBRSwrQkFDTCxLQUFLdEQsT0FBTCxDQUFhc0QsUUFEVjtBQUVOdEQsbUJBQU8sRUFBRXFFO0FBRkg7QUFESCxTQUFQO0FBTUQ7QUF0QmlFO0FBQUE7QUFBQSwyQ0F3QjdDO0FBQUE7O0FBQ25CaEIsaUJBQVEsQ0FBQ3hGLEtBQVQsQ0FBZSxZQUFNO0FBQ25CLGNBQUksT0FBT3FJLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEMsZ0JBQUlJLEtBQUssR0FBRyxJQUFaO0FBQ0EsZ0JBQUlELE1BQU0sR0FBRyxJQUFiOztBQUNBLGdCQUFJO0FBQ0ZBLG9CQUFNLEdBQUcsTUFBSSxDQUFDckcsT0FBTCxDQUFhc0QsUUFBYixDQUFzQjFDLEdBQXRCLENBQTBCc0YsVUFBMUIsRUFBc0NsRyxPQUFPLElBQUlBLE9BQU8sQ0FBQ0EsT0FBekQsQ0FBVDtBQUNBc0csbUJBQUssR0FBRyxLQUFSO0FBQ0QsYUFIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNWLG9CQUFJLENBQUNoQixRQUFMLENBQWM7QUFBRWMsc0JBQU0sRUFBTkEsTUFBRjtBQUFVQyxxQkFBSyxFQUFMQTtBQUFWLGVBQWQsRUFEVSxDQUdWOzs7QUFDQSxvQkFBTUMsQ0FBTjtBQUNEOztBQUVELGtCQUFJLENBQUNoQixRQUFMLENBQWM7QUFBRWMsb0JBQU0sRUFBTkEsTUFBRjtBQUFVQyxtQkFBSyxFQUFMQTtBQUFWLGFBQWQ7O0FBQ0E7QUFDRDs7QUFFRCxnQkFBSSxDQUFDZixRQUFMLENBQWM7QUFBRWMsa0JBQU0sRUFBRUg7QUFBVixXQUFkO0FBQ0QsU0FuQkQ7QUFvQkQ7QUE3Q2lFO0FBQUE7QUFBQSwrQkErQ3pEO0FBQ1AsWUFBTU0sTUFBTSxHQUFHLEtBQUtyQixLQUFMLENBQVdrQixNQUExQjs7QUFDQSxZQUFJLEtBQUtsQixLQUFMLENBQVdtQixLQUFmLEVBQXNCO0FBQ3BCLGNBQUlHLFFBQVEsR0FBR2QsOENBQWY7O0FBQ0EsY0FBSTtBQUNGYyxvQkFBUSxHQUFHLEtBQUt6RyxPQUFMLENBQWFzRCxRQUFiLENBQXNCMUMsR0FBdEIsQ0FBMEIsbUJBQTFCLENBQVg7QUFDRCxXQUZELENBRUUsT0FBTzJGLENBQVAsRUFBVSxDQUNWO0FBQ0Q7O0FBQ0QsaUJBQU8sOEJBQUMsUUFBRCxlQUFjLEtBQUtyQyxLQUFuQjtBQUEwQixvQkFBUSxFQUFFZ0M7QUFBcEMsYUFBUDtBQUNEOztBQUVELFlBQUlNLE1BQUosRUFBWTtBQUNWLGlCQUNJLDhCQUFDLE1BQUQsRUFBWSxLQUFLdEMsS0FBakIsQ0FESjtBQUdEOztBQUNELGVBQU8sSUFBUDtBQUNEO0FBakVpRTs7QUFBQTtBQUFBLElBQ3pDQyxrQkFEeUM7O0FBb0VwRWlDLGNBQVksQ0FBQ2hDLGlCQUFiLEdBQWlDTSxlQUFqQztBQUVBLE1BQU1nQyxlQUFlLEdBQUdQLGdCQUFnQixJQUFJdkMsb0NBQTVDO0FBRUEsU0FBTzhDLGVBQWUsQ0FBQy9CLGlDQUFZLENBQUN5QixZQUFELENBQWIsQ0FBdEI7QUFDRCxDQXpFRDs7QUEyRWVILGtHQUFmLEU7O0FDaEdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFlVSwrRkFBZiIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJ1aWxkSW5qZWN0b3JDb250YWluZXIgPSAoKSA9PiAoe1xuICAvKipcbiAgICogQSBtYXAgb2Ygc2VydmljZXNcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gIHNlcnZpY2VzOiB7fSxcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCBESSBpcyBibG9ja2VkXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxuXG4gIGNhbGxiYWNrczogW10sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgc2VydmljZSBmb3IgdGhlIGluamVjdG9yIHRvIHByb3ZpZGVcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIGZvcmNlXG4gICAqL1xuICByZWdpc3RlcihrZXksIHZhbHVlLCB7IGZvcmNlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtdXRhdGUgREkgY29udGFpbmVyIGFmdGVyIGl0IGhhcyBiZWVuIGluaXRpYWxpc2VkJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcnZpY2VzW2tleV0gJiYgZm9yY2UgIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBUcmllZCB0byByZWdpc3RlciBzZXJ2aWNlICR7a2V5fSBtb3JlIHRoYW4gb25jZS4gVGhpcyBwcmFjdGljZSBpcyBkaXNjb3VyYWdlZC4gQ29uc2lkZXJcbiAgICAgIHVzaW5nIEluamVjdG9yLnVwZGF0ZSgpIHRvIGVuaGFuY2UgdGhlIHNlcnZpY2UgcmF0aGVyIHRoYW4gb3ZlcnJpZGUgaXQgY29tcGxldGVseS5cbiAgICAgIE90aGVyd2lzZSwgaW52b2tlIHRoZSByZWdpc3RlcigpIGZ1bmN0aW9uIHdpdGggeyBmb3JjZTogdHJ1ZSB9IGFzIHRoZSB0aGlyZCBhcmd1bWVudC5cbiAgICAgYCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzW2tleV0gIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnNlcnZpY2VzW2tleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBUcmllZCB0byByZWdpc3RlciBzZXJ2aWNlICR7a2V5fSB3aGljaCBpcyBhIHJlc2VydmVkIGtleXdvcmQuIFRoaXMgd291bGQgYWZmZWN0IHRoZSBiZWhhdmlvdXJcbiAgICAgIG9mIHRoaXMgQVBJIGNsYXNzLCBzbyBpdCBpcyBmb3JiaWRkZW4gdG8gcmVnaXN0ZXIgd2l0aCBJbmplY3Rvci5cbiAgICAgIGApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVpcmVkTWV0aG9kcyA9IFsnbG9hZCcsICdjcmVhdGVUcmFuc2Zvcm1lcicsICdnZXQnLCAncmVnaXN0ZXInXTtcbiAgICBpZiAoIXJlcXVpcmVkTWV0aG9kcy5ldmVyeShtZXRob2QgPT4gdHlwZW9mIHZhbHVlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgVHJpZWQgdG8gcmVnaXN0ZXIgc2VydmljZSAke2tleX0gdGhhdCBpcyBub3QgYSB2YWxpZCBvYmplY3QsIEluamVjdG9yIHJlcXVpcmVzIGFuIG9iamVjdFxuICAgICAgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBtZXRob2RzOiAke3JlcXVpcmVkTWV0aG9kcy5qb2luKCcsICcpfVxuICAgICAgYCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXJ2aWNlc1trZXldID0gdmFsdWU7XG5cbiAgICAvLyBnbG9iYWxseSBleHBvc2UgdGhlIHNlcnZpY2UgYXMgd2VsbFxuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyBlYWNoIHNlcnZpY2UgdGhhdCB3YXMgcmVnaXN0ZXJlZFxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbXV0YXRlIERJIGNvbnRhaW5lciBhZnRlciBpdCBoYXMgYmVlbiBpbml0aWFsaXNlZCcpO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKHRoaXMuc2VydmljZXMpXG4gICAgICAuZm9yRWFjaChzZXJ2aWNlID0+IHNlcnZpY2UubG9hZCgpKTtcblxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFuIG9iamVjdCB0byBhIGNhbGxiYWNrIHdoaWNoIGFsbG93cyBxdWljayBhY2Nlc3MgdG8gaW5kaXZpZHVhbCBzZXJ2aWNlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtvYmplY3R9IHByaW9yaXRpZXMgQW4gb2JqZWN0IG1hcHBpbmcgcHJpb3JpdGllcyBmb3IgdGhlIGxvYWRpbmcgb3JkZXI6XG4gICAqICB7IGJlZm9yZTogJ3NvbWUtdHJhbnNmb3JtYXRpb24nLCBhZnRlcjogJ3NvbWUtb3RoZXItdHJhbnNmb3JtYXRpb24nIH1cbiAgICovXG4gIHRyYW5zZm9ybShuYW1lLCBjYWxsYmFjaywgcHJpb3JpdGllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGlzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11dGF0ZSBESSBjb250YWluZXIgYWZ0ZXIgaXQgaGFzIGJlZW4gaW5pdGlhbGlzZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVyID0gT2JqZWN0LmVudHJpZXModGhpcy5zZXJ2aWNlcykucmVkdWNlKFxuICAgICAgKHVwZGF0ZUNvbnRhaW5lciwgW3NlcnZpY2VOYW1lLCBzZXJ2aWNlXSkgPT4gKHtcbiAgICAgICAgLi4udXBkYXRlQ29udGFpbmVyLFxuICAgICAgICBbc2VydmljZU5hbWVdOiBzZXJ2aWNlLmNyZWF0ZVRyYW5zZm9ybWVyKG5hbWUsIHByaW9yaXRpZXMpLFxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgY2FsbGJhY2sodXBkYXRlcik7XG4gIH0sXG5cbiAgcmVhZHkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHByb3ZpZGVkIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tzID0gW1xuICAgICAgLi4udGhpcy5jYWxsYmFja3MsXG4gICAgICBjYWxsYmFjayxcbiAgICBdO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkSW5qZWN0b3JDb250YWluZXI7XG4iLCJpbXBvcnQgdG9wb3NvcnQgZnJvbSAndG9wb3NvcnQnO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEJFRk9SRSA9ICdiZWZvcmUnO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEFGVEVSID0gJ2FmdGVyJztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBHUkFQSF9IRUFEID0gJ19fSEVBRF9fJztcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBHUkFQSF9UQUlMID0gJ19fVEFJTF9fJztcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsb3dlZCBwcmlvcml0aWVzIHRoYXQgY2FuIGJlIHNwZWNpZmllZCBhcyBtZXRhZGF0YVxuICogQHR5cGUge0FycmF5fVxuICovXG5jb25zdCBQUklPUklUSUVTID0gW0JFRk9SRSwgQUZURVJdO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNvbnRleHQsIGlmIG5vbmUgaXMgZ2l2ZW5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEdMT0JBTF9DT05URVhUID0gJ19fR0xPQkFMX18nO1xuXG4vKipcbiAqIFRoZSB3aWxkY2FyZCBvcGVyYXRvciwgdXNlZCBmb3IgcHJpb3JpdGllc1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgV0lMRENBUkQgPSAnKic7XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBtZXRhZGF0YSBwYXNzZWQgdG8gdGhlIGluamVjdG9yIGN1c3RvbWlzYXRpb25cbiAqIEBwYXJhbSBtZXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlTWV0YSA9IChtZXRhKSA9PiB7XG4gIFBSSU9SSVRJRVMuZm9yRWFjaChrID0+IHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0YVtrXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICh0eXBlb2YgbWV0YVtrXSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkobWV0YVtrXSkpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pZGRsZXdhcmUga2V5ICR7a30gbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheWApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgdXNlIG9mIGEgd2lsZGNhcmQgKCopIHNwZWNpZmljYXRpb24gb24gYSBtaWRkbGV3YXJlIG9iamVjdC5cbiAqIEl0IHNob3VsZDpcbiAqIC0tIEJlIHNpbmd1bGFyXG4gKiAgQkFEOiB7IGFmdGVyOiBbJyonLCAnc29tZXRoaW5nLWVsc2UnXSB9XG4gKiAgR09PRDogeyBhZnRlcjogWycqJ10gfVxuICogLS0gQmUgdGhlIG9ubHkgcHJpb3JpdHkgcnVsZVxuICogICBCQUQ6IHsgYWZ0ZXI6IFsnKiddLCBiZWZvcmU6ICdzb21ldGhpbmcnIH1cbiAqICAgR09PRDogeyBhZnRlcjogWycqJ10gfVxuICogQHBhcmFtIG1pZGRsZXdhcmVcbiAqIEByZXR1cm5zIFRoZSBwcmlvcml0eSAoYmVmb3JlL2FmdGVyKSBvZiB0aGUgd2lsZGNhcmQgYmVpbmcgdXNlZFxuICovXG5jb25zdCBjaGVja1dpbGRjYXJkID0gKG1pZGRsZXdhcmUpID0+IHtcbiAgbGV0IHdpbGRjYXJkID0gbnVsbDtcbiAgUFJJT1JJVElFUy5mb3JFYWNoKFBSSU9SSVRZID0+IHtcbiAgICBpZiAobWlkZGxld2FyZVtQUklPUklUWV0uaW5jbHVkZXMoV0lMRENBUkQpKSB7XG4gICAgICBpZiAobWlkZGxld2FyZVtQUklPUklUWV0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgIEtleSAke1BSSU9SSVRZfSBvbiAke21pZGRsZXdhcmUubmFtZX0gc2hvdWxkIG9ubHkgc3BlY2lmeSBvbmUga2V5IFxuICAgICAgICAgIGlmIHVzaW5nIHRoZSBcIiR7V0lMRENBUkR9XCIgd2lsZGNhcmRcbiAgICAgICAgYCk7XG4gICAgICB9IGVsc2UgaWYgKHdpbGRjYXJkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgQ2Fubm90IHNwZWNpZnkgYSAke1BSSU9SSVRZfSBydWxlIG9uICR7bWlkZGxld2FyZS5uYW1lfSBpZiBhIHdpbGRjYXJkIFxuICAgICAgICAgIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAgICBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbGRjYXJkID0gUFJJT1JJVFk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gd2lsZGNhcmQ7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIG9mIHRoZSBtaWRkbGV3YXJlIHJlZ2lzdHJ5LiBIb2xkcyBhIHNldCBvZiBtaWRkbGV3YXJlc1xuICogZm9yIGEgZ2l2ZW4gc2VydmljZSBhbmQgbmVnb3RpYXRlcyBwcmlvcml0aWVzIGFuZCBjb250ZXh0cyB0byBjcmVhdGVcbiAqIGEgZmFjdG9yeS4gRmFjdG9yaWVzIGFyZSBjYWNoZWQgZm9yIGVhY2ggY29udGV4dC5cbiAqL1xuY2xhc3MgTWlkZGxld2FyZVJlZ2lzdHJ5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9taWRkbGV3YXJlcyA9IFtdO1xuICAgIHRoaXMuX2NvbnRleHRDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSB0b3BvbG9naWNhbCBzb3J0IHRvIHRoZSBtaWRkbGV3YXJlcyBhbmQgcmVzb2x2ZXNcbiAgICogcHJpb3JpdHkgZGVjbGFyYXRpb25zXG4gICAqL1xuICBzb3J0KCkge1xuICAgIC8qIEluaXRpYWxpc2UgdGhlIGdyYXBoIHdpdGggaGVhZCBhbmQgdGFpbCBwbGFjZWhvbGRlcnMgc28gdGhhdCBjdXN0b21pc2F0aW9uc1xuICAgICB3aXRoIG5vIGJlZm9yZS9hZnRlciBzcGVjaWZpZWQgaGF2ZSBhIHJlZmVyZW5jZSBwb2ludCAqL1xuICAgIGNvbnN0IEdSQVBIX0lOSVQgPSBbR1JBUEhfSEVBRCwgR1JBUEhfVEFJTF07XG4gICAgY29uc3QgZ3JhcGggPSBbR1JBUEhfSU5JVF07XG4gICAgbGV0IHNvcnRlZE1pZGRsZXdhcmVzID0gW107XG4gICAgdGhpcy5fbWlkZGxld2FyZXMuZm9yRWFjaChtaWRkbGV3YXJlID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSB9ID0gbWlkZGxld2FyZTtcbiAgICAgIGNvbnN0IHdpbGRjYXJkID0gY2hlY2tXaWxkY2FyZChtaWRkbGV3YXJlKTtcbiAgICAgIGlmICh3aWxkY2FyZCA9PT0gQUZURVIpIHtcbiAgICAgICAgZ3JhcGgucHVzaChbR1JBUEhfVEFJTCwgbmFtZV0pO1xuICAgICAgfSBlbHNlIGlmICh3aWxkY2FyZCA9PT0gQkVGT1JFKSB7XG4gICAgICAgIGdyYXBoLnB1c2goW25hbWUsIEdSQVBIX0hFQURdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcsIG90aGVyIHRoYW4gd2lsZGNhcmRzLCBnb2VzIGJldHdlZW4gaGVhZCBhbmQgdGFpbFxuICAgICAgICAvLyBhdCBhIG1pbmltdW1cbiAgICAgICAgZ3JhcGgucHVzaChbbmFtZSwgR1JBUEhfVEFJTF0pO1xuICAgICAgICBncmFwaC5wdXNoKFtHUkFQSF9IRUFELCBuYW1lXSk7XG5cbiAgICAgICAgbWlkZGxld2FyZVtCRUZPUkVdLmZvckVhY2goYmVmb3JlRW50cnkgPT4ge1xuICAgICAgICAgIGdyYXBoLnB1c2goW25hbWUsIGJlZm9yZUVudHJ5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtaWRkbGV3YXJlW0FGVEVSXS5mb3JFYWNoKGFmdGVyRW50cnkgPT4ge1xuICAgICAgICAgIGdyYXBoLnB1c2goW2FmdGVyRW50cnksIG5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgdGhlIHRvcG9sb2dpY2FsIHNvcnQgYW5kIHN0cmlwIG91dCB0aGUgcGxhY2Vob2xkZXJzXG4gICAgdG9wb3NvcnQoZ3JhcGgpXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gIUdSQVBIX0lOSVQuaW5jbHVkZXMoaXRlbSkpXG4gICAgICAuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgc29ydGVkTWlkZGxld2FyZXMgPSBzb3J0ZWRNaWRkbGV3YXJlcy5jb25jYXQoXG4gICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXMuZmlsdGVyKG0gPT4gbS5uYW1lID09PSBuYW1lKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHNvcnRlZE1pZGRsZXdhcmVzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBuZXcgbWlkZGxld2FyZSB0byB0aGUgbGlzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YSBBbiBvYmplY3Qgb2YgbWV0YSBkYXRhIHsgbmFtZSwgYmVmb3JlLCBhZnRlciB9XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIG1pZGRsZXdhcmUgKGRlY29yYXRvcikgdG8gYXBwbHkgdG8gdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHtBcnJheX0gY29udGV4dExpc3QgQW4gYXJyYXkgb2YgaGllcmFyY2hpY2FsIGNvbnRleHQsIFsnVW5pdmVyc2UnLCAnRWFydGgnLCAnTlonXVxuICAgKi9cbiAgYWRkKG1ldGEsIGZhY3RvcnksIGNvbnRleHRMaXN0KSB7XG4gICAgdmFsaWRhdGVNZXRhKG1ldGEpO1xuXG4gICAgLy8gSW52YWxpZGF0ZSB0aGUgY2FjaGUgd2hlbiBuZXcgbWlkZGxld2FyZXMgYXJlIGFkZGVkXG4gICAgdGhpcy5fY29udGV4dENhY2hlID0ge307XG4gICAgbGV0IGNvbnRleHQgPSBjb250ZXh0TGlzdDtcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQubGVuZ3RoKSB7XG4gICAgICBjb250ZXh0ID0gW0dMT0JBTF9DT05URVhUXTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gW2NvbnRleHRdO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGlzZWQgPSB7IC4uLm1ldGEsIGZhY3RvcnksIGNvbnRleHQgfTtcbiAgICAvLyBtYWtlIHN1cmUgYmVmb3JlL2FmdGVyIGFyZSBhdCBsZWFzdCBlbXB0eSBhcnJheXNcbiAgICBQUklPUklUSUVTLmZvckVhY2goayA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0YVtrXSkpIHtcbiAgICAgICAgbm9ybWFsaXNlZFtrXSA9IG1ldGFba10gPyBbbWV0YVtrXV0gOiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGlzZWRba10gPSBtZXRhW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIG5vIGJlZm9yZS9hZnRlciBpcyBzcGVjaWZpZWQsIHB1dCBpdCBiZXR3ZWVuIHRoZSBoZWFkIGFuZCB0YWlsXG4gICAgaWYgKFBSSU9SSVRJRVMuZXZlcnkocCA9PiAhbm9ybWFsaXNlZFtwXS5sZW5ndGgpKSB7XG4gICAgICBub3JtYWxpc2VkW0FGVEVSXSA9IFtHUkFQSF9IRUFEXTtcbiAgICAgIG5vcm1hbGlzZWRbQkVGT1JFXSA9IFtHUkFQSF9UQUlMXTtcbiAgICB9XG5cbiAgICB0aGlzLl9taWRkbGV3YXJlcy5wdXNoKG5vcm1hbGlzZWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBkb3Qtc2VwYXJhdGVkIGNvbnRleHQgc3BlYywgZmluZCBhbGwgdGhlIHJlZ2lzdGVyZWQgbWlkZGxld2FyZXMgdGhhdCBhcHBseVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRNYXRjaGVzRm9yQ29udGV4dChjb250ZXh0ID0gR0xPQkFMX0NPTlRFWFQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRleHRDYWNoZVtjb250ZXh0XSkge1xuICAgICAgY29uc3QgcmVxdWVzdGVkQ29udGV4dCA9IGNvbnRleHQuc3BsaXQoJy4nKTtcbiAgICAgIHRoaXMuX2NvbnRleHRDYWNoZVtjb250ZXh0XSA9IHRoaXMuX21pZGRsZXdhcmVzLmZpbHRlcihtaWRkbGV3YXJlID0+IChcbiAgICAgICAgbWlkZGxld2FyZS5jb250ZXh0WzBdID09PSBHTE9CQUxfQ09OVEVYVCB8fFxuICAgICAgICBtaWRkbGV3YXJlLmNvbnRleHQuZXZlcnkoKHBhcnQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgcGFydCA9PT0gV0lMRENBUkQgfHwgcmVxdWVzdGVkQ29udGV4dFtpbmRleF0gPT09IHBhcnRcbiAgICAgICAgKSlcbiAgICAgICkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dENhY2hlW2NvbnRleHRdO1xuICB9XG59XG5cbmV4cG9ydCB7IEdMT0JBTF9DT05URVhUIH07XG5cbmV4cG9ydCBkZWZhdWx0IE1pZGRsZXdhcmVSZWdpc3RyeTtcbiIsImltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byAnICsgJ2NyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtICcgKyAndG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgJyArICdjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpLXJlZmVyZW5jZS9zdG9yZSNzdWJzY3JpYmUobGlzdGVuZXIpIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS1yZWZlcmVuY2Uvc3RvcmUjc3Vic2NyaWJlKGxpc3RlbmVyKSBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0aW9uID0gYWN0aW9uVHlwZSAmJiBcImFjdGlvbiBcXFwiXCIgKyBTdHJpbmcoYWN0aW9uVHlwZSkgKyBcIlxcXCJcIiB8fCAnYW4gYWN0aW9uJztcbiAgcmV0dXJuIFwiR2l2ZW4gXCIgKyBhY3Rpb25EZXNjcmlwdGlvbiArIFwiLCByZWR1Y2VyIFxcXCJcIiArIGtleSArIFwiXFxcIiByZXR1cm5lZCB1bmRlZmluZWQuIFwiICsgXCJUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIFwiICsgXCJJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5cIjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIFwiVGhlIFwiICsgYXJndW1lbnROYW1lICsgXCIgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcXFwiXCIgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArIFwiXFxcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBcIiArIChcImtleXM6IFxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiXCIpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBcIiArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgXCIgXCIgKyAoXCJcXFwiXCIgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIiBmb3VuZCBpbiBcIiArIGFyZ3VtZW50TmFtZSArIFwiLiBcIikgKyBcIkV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIgKyAoXCJcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZHVjZXIgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIFwiICsgXCJJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgXCIgKyBcImV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgXCIgKyBcIm5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIFwiICsgXCJ5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2VyIFxcXCJcIiArIGtleSArIFwiXFxcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiBcIiArIChcIkRvbid0IHRyeSB0byBoYW5kbGUgXCIgKyBBY3Rpb25UeXBlcy5JTklUICsgXCIgb3Igb3RoZXIgYWN0aW9ucyBpbiBcXFwicmVkdXgvKlxcXCIgXCIpICsgXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBcIiArIFwiY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgXCIgKyBcImluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBcIiArIFwiYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKFwiTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcblxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkIFwiICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArIFwiLiBcIiArIFwiRGlkIHlvdSB3cml0ZSBcXFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cXFwiIGluc3RlYWQgb2YgXFxcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cXFwiP1wiKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gXCIgKyBcIk90aGVyIG1pZGRsZXdhcmUgd291bGQgbm90IGJlIGFwcGxpZWQgdG8gdGhpcyBkaXNwYXRjaC5cIik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodm9pZCAwLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cbi8qXG4gKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4gKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4gKi9cblxuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgd2FybmluZygnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIi4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIHNldHRpbmcgbW9kZSB0byBwcm9kdWN0aW9uIGluIHdlYnBhY2sgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uY2VwdHMvbW9kZS8pICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUsIGNvbWJpbmVSZWR1Y2VycywgYmluZEFjdGlvbkNyZWF0b3JzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UsIEFjdGlvblR5cGVzIGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMgfTtcbiIsImltcG9ydCBNaWRkbGV3YXJlUmVnaXN0cnksIHsgR0xPQkFMX0NPTlRFWFQgfSBmcm9tICcuL01pZGRsZXdhcmVSZWdpc3RyeSc7XG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSAncmVkdXgnO1xuXG5jb25zdCBidWlsZEJhc2VDb250YWluZXIgPSAoKSA9PiAoe1xuICAvKipcbiAgICogU3RvcmUgb2YgbWlkZGxld2FyZSByZWdpc3RyaWVzXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuICBtaWRkbGV3YXJlUmVnaXN0cmllczoge30sXG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIHNlcnZpY2VzXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuICBzZXJ2aWNlczoge30sXG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIGZhY3RvcmllcyB0byB0aGUgc2VydmljZXNcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gIGZhY3Rvcmllczoge30sXG5cbiAgZmFjdG9yeUNhY2hlOiB7fSxcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCBESSBpcyBibG9ja2VkXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxuXG4gIGlzUHJvdGVjdGVkKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtdXRhdGUgREkgY29udGFpbmVyIGFmdGVyIGl0IGhhcyBiZWVuIGluaXRpYWxpc2VkJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgZGVwZW5kZW5jeVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IEEgZG90LXNlcGFyYXRlZCBjb250ZXh0IHNwZWNpZmljYXRpb25cbiAgICogQHJldHVybnMge29iamVjdH0gQ29tcG9uZW50XG4gICAqL1xuICBnZXQoa2V5LCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgSW5qZWN0b3IuZ2V0KCk6IEF0dGVtcHRlZCB0byBhY2Nlc3MgREkgbGF5ZXIgYmVmb3JlIGl0IHdhcyBpbml0aWFsaXNlZC5cbiAgICAgIERpZCB5b3UgZm9yZ2V0IHRvIGludm9rZSBJbmplY3Rvci5sb2FkKCk/YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzW2tleV07XG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluamVjdG9yLmdldCgpOiBDb21wb25lbnQgJHtrZXl9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhY3RvcnkoY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGNvbXBvc2UgYW4gZXhpc3RpbmcgY29tcG9uZW50XG4gICAqIHdpdGggbmV3IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG1ldGEgQW4gb2JqZWN0IG9mIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVuY3kgdG8gY3VzdG9taXNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb21wb3NlIHRoZSBkZXBlbmRlbmN5LiBHZXRzIHBhc3NlZCB0aGVcbiAgICogIHByZXZpb3VzIHN0YXRlIG9mIGNvbXBvc2l0aW9uXG4gICAqL1xuICBjdXN0b21pc2UobWV0YSwga2V5LCBmYWN0b3J5KSB7XG4gICAgdGhpcy5pc1Byb3RlY3RlZCgpO1xuXG4gICAgY29uc3QgW3NlcnZpY2VOYW1lLCAuLi5jb250ZXh0XSA9IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCByZWdpc3RyeSA9IHRoaXMubWlkZGxld2FyZVJlZ2lzdHJpZXNbc2VydmljZU5hbWVdO1xuICAgIGlmICghcmVnaXN0cnkpIHtcbiAgICAgIHJlZ2lzdHJ5ID0gbmV3IE1pZGRsZXdhcmVSZWdpc3RyeSgpO1xuICAgICAgdGhpcy5taWRkbGV3YXJlUmVnaXN0cmllcyA9IHtcbiAgICAgICAgLi4udGhpcy5taWRkbGV3YXJlUmVnaXN0cmllcyxcbiAgICAgICAgW3NlcnZpY2VOYW1lXTogcmVnaXN0cnksXG4gICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RyeS5hZGQoXG4gICAgICBtZXRhLFxuICAgICAgZmFjdG9yeSxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFsbCBvZiB0aGUgbWlkZGxld2FyZSBjb25zdHJhaW50cyBhbmQgZnJlZXplIHRoZSBESSBsYXllclxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmlzUHJvdGVjdGVkKCk7XG4gICAgdGhpcy5mYWN0b3JpZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNlcnZpY2VzKVxuICAgICAgLnJlZHVjZSgoZmFjdG9yaWVzLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9IHRoaXMubWlkZGxld2FyZVJlZ2lzdHJpZXNba2V5XTtcbiAgICAgICAgaWYgKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgICBtaWRkbGV3YXJlLnNvcnQoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5mYWN0b3JpZXMsXG4gICAgICAgICAgICBba2V5XTogKGNvbnRleHQgPSBHTE9CQUxfQ09OVEVYVCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGAke2tleX1fXyR7Y29udGV4dH1gO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuZmFjdG9yeUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBtaWRkbGV3YXJlLmdldE1hdGNoZXNGb3JDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yeUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuZ2V0RmFjdG9yeShrZXksIG1hdGNoZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yeUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZhY3RvcmllcyxcbiAgICAgICAgICBba2V5XTogKCkgPT4gdGhpcy5nZXRGYWN0b3J5KGtleSwgW10pLFxuICAgICAgICB9O1xuICAgICAgfSwge30pO1xuXG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVwZW5kZW5jeS4gVGhpcyBpcyB0aGUgaW5pdGlhbCB2ZXJzaW9uIG9mIGEgZGVwZW5kZW5jeSB0aGF0IHdpbGwgYmVcbiAgICogcGFzc2VkIHRvIHRoZSBmaXJzdCBsaW5rIGluIHRoZSBtaWRkbGV3YXJlIGNoYWluIChpZiBhbnkgY3VzdG9taXNhdGlvbnMgZXhpc3QpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUgZGVwZW5kZW5jeSB0byByZWdpc3RlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB2YWx1ZSAtIFRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIFdoZXRoZXIgdG8gZm9yY2UgdGhlIGdpdmVuIGtleSB0byBvdmVycmlkZSBhbiBleGlzdGluZyBrZXlcbiAgICovXG4gIHJlZ2lzdGVyKGtleSwgdmFsdWUsIHsgZm9yY2UgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1Byb3RlY3RlZCgpO1xuXG4gICAgaWYgKHRoaXMuc2VydmljZXNba2V5XSAmJiBmb3JjZSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIFRyaWVkIHRvIHJlZ2lzdGVyIHNlcnZpY2UgJyR7a2V5fScgbW9yZSB0aGFuIG9uY2UuIFRoaXMgcHJhY3RpY2UgaXMgZGlzY291cmFnZWQuIENvbnNpZGVyXG4gICAgICB1c2luZyBJbmplY3Rvci51cGRhdGUoKSB0byBlbmhhbmNlIHRoZSBzZXJ2aWNlIHJhdGhlciB0aGFuIG92ZXJyaWRlIGl0IGNvbXBsZXRlbHkuXG4gICAgICBPdGhlcndpc2UsIGludm9rZSB0aGUgcmVnaXN0ZXIoKSBmdW5jdGlvbiB3aXRoIHsgZm9yY2U6IHRydWUgfSBhcyB0aGUgdGhpcmQgYXJndW1lbnQuXG4gICAgIGApO1xuICAgIH1cbiAgICB0aGlzLnNlcnZpY2VzID0ge1xuICAgICAgLi4udGhpcy5zZXJ2aWNlcyxcbiAgICAgIFtrZXldOiB2YWx1ZSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBtYW55IGRlcGVuZGVuY2llcy4gVGhpcyB3aWxsIGJlIGEgbGlzdCBvZiB0aGUgaW5pdGlhbCB2ZXJzaW9uIG9mIGEgZGVwZW5kZW5jeSB0aGF0XG4gICAqIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaXJzdCBsaW5rIGluIHRoZSBtaWRkbGV3YXJlIGNoYWluIChpZiBhbnkgY3VzdG9taXNhdGlvbnMgZXhpc3QpXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXAgLSBUaGUgbmFtZS12YWx1ZSBtYXBwaW5nIG9mIHRoZSBkZXBlbmRlbmNpZXMgdG8gcmVnaXN0ZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIFdoZXRoZXIgdG8gZm9yY2UgdGhlIGdpdmVuIGtleSB0byBvdmVycmlkZSBhbiBleGlzdGluZyBrZXlcbiAgICovXG4gIHJlZ2lzdGVyTWFueShtYXAsIHsgZm9yY2UgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1Byb3RlY3RlZCgpO1xuXG4gICAgY29uc3QgbWFwS2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBPYmplY3Qua2V5cyh0aGlzLnNlcnZpY2VzKS5maWx0ZXIoKHNlcnZpY2UpID0+IChcbiAgICAgIG1hcEtleXMuaW5jbHVkZXMoc2VydmljZSlcbiAgICApKTtcbiAgICBpZiAoZXhpc3RpbmcubGVuZ3RoICYmIGZvcmNlICE9PSB0cnVlKSB7XG4gICAgICBjb25zdCBsaXN0ID0gZXhpc3Rpbmcuam9pbignLCAnKTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIFRyaWVkIHRvIHJlZ2lzdGVyIHNlcnZpY2VzICgke2xpc3R9KSBtb3JlIHRoYW4gb25jZS4gVGhpcyBwcmFjdGljZSBpcyBkaXNjb3VyYWdlZC4gQ29uc2lkZXJcbiAgICAgIHVzaW5nIEluamVjdG9yLnVwZGF0ZSgpIHRvIGVuaGFuY2UgdGhlIHNlcnZpY2UgcmF0aGVyIHRoYW4gb3ZlcnJpZGUgaXQgY29tcGxldGVseS5cbiAgICAgIE90aGVyd2lzZSwgaW52b2tlIHRoZSByZWdpc3RlcigpIGZ1bmN0aW9uIHdpdGggeyBmb3JjZTogdHJ1ZSB9IGFzIHRoZSB0aGlyZCBhcmd1bWVudC5cbiAgICAgYCk7XG4gICAgfVxuICAgIHRoaXMuc2VydmljZXMgPSB7XG4gICAgICAuLi50aGlzLnNlcnZpY2VzLFxuICAgICAgLi4ubWFwLFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGluamVjdG9yIGJ5IGNhbGxiYWNrLiBGaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGNvbnRhaW5cbiAgICogYW4gb2JqZWN0IHdpdGgga2V5cyBmb3IgbmFtZSwgYW5kIChvcHRpb25hbCkgXCJiZWZvcmVcIiBhbmQgXCJhZnRlclwiIGRlY2xhcmF0aW9uc1xuICAgKiBlLnguXG4gICAqIEluamVjdG9yLnRyYW5zZm9ybSgnbXktdHJhbnNmb3JtYXRpb24tbmFtZScsICh1cGRhdGUpID0+IHtcbiAgICogIHVwZGF0ZSgnU29tZUNvbXBvbmVudCcsIE15TmV3Q29tcG9uZW50Q3JlYXRvcik7XG4gICAqIH0sIHsgYmVmb3JlOiAnYW5vdGhlci10cmFuc2Zvcm0nIH0pO1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtvYmplY3R9IHByaW9yaXRpZXMgQW4gb2JqZWN0IG1hcHBpbmcgcHJpb3JpdGllcyBmb3IgdGhlIGxvYWRpbmcgb3JkZXI6XG4gICAqICB7IGJlZm9yZTogJ3NvbWUtdHJhbnNmb3JtYXRpb24nLCBhZnRlcjogJ3NvbWUtb3RoZXItdHJhbnNmb3JtYXRpb24nIH1cbiAgICovXG4gIHRyYW5zZm9ybShuYW1lLCBjYWxsYmFjaywgcHJpb3JpdGllcyA9IHt9KSB7XG4gICAgdGhpcy5pc1Byb3RlY3RlZCgpO1xuXG4gICAgY2FsbGJhY2sodGhpcy5jcmVhdGVUcmFuc2Zvcm1lcihuYW1lLCBwcmlvcml0aWVzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjdXN0b21pc2UoKSBmdW5jdGlvbiBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJpb3JpdGllc1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAqL1xuICBjcmVhdGVUcmFuc2Zvcm1lcihuYW1lLCBwcmlvcml0aWVzKSB7XG4gICAgcmV0dXJuIChrZXksIHdyYXBwZXIpID0+IHtcbiAgICAgIHRoaXMuY3VzdG9taXNlKHsgbmFtZSwgLi4ucHJpb3JpdGllcyB9LCBrZXksIHdyYXBwZXIpO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmYWN0b3J5IG1ldGhvZCBmb3IgYSBzZXJ2aWNlLCBpbmNvcnBvcmF0aW5nIGFsbCB0aGUgZ2l2ZW4gbWlkZGxld2FyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5fSBtaWRkbGV3YXJlTWF0Y2hlc1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAqL1xuICBnZXRGYWN0b3J5KGtleSwgbWlkZGxld2FyZU1hdGNoZXMpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5zZXJ2aWNlc1trZXldO1xuICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gbWlkZGxld2FyZU1hdGNoZXMubWFwKG0gPT4gbS5mYWN0b3J5KTtcbiAgICByZXR1cm4gY29tcG9zZSguLi5taWRkbGV3YXJlcykoc2VydmljZSk7XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRCYXNlQ29udGFpbmVyO1xuIiwiaW1wb3J0IGJ1aWxkQmFzZUNvbnRhaW5lciBmcm9tICcuL2J1aWxkQmFzZUNvbnRhaW5lcic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRpc3BsYXkgbmFtZSBmb3IgYSBmaW5hbCBjb21wb3NlZCBjb21wb25lbnQgZ2l2ZW4gYWxsXG4gKiB0aGUgbmFtZXMgb2YgdGhlIG11dGF0aW9ucyB0aGF0IGFmZmVjdGVkIGl0LlxuICogZS5nLiBteS10cmFuc2Zvcm1hdGlvbihUZXh0RmllbGQpXG4gKiBAcGFyYW0gb3JpZ2luYWwgVGhlIG9yaWdpbmFsIHJlZ2lzdGVyZWQgY29tcG9uZW50XG4gKiBAcGFyYW0gdHJhbnNmb3JtcyBUaGUgbGlzdCBvZiB0cmFuc2Zvcm1hdGlvbiBuYW1lcyB0aGF0IG1vZGlmaWVkIHRoZSBjb21wb25lbnRcbiAqL1xuY29uc3QgY3JlYXRlRGlzcGxheU5hbWUgPSAob3JpZ2luYWwsIHRyYW5zZm9ybXMpID0+IHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IChvcmlnaW5hbC5kaXNwbGF5TmFtZSB8fCBvcmlnaW5hbC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgY29uc3QgbmFtZXMgPSBbY29tcG9uZW50TmFtZSwgLi4udHJhbnNmb3Jtc107XG5cbiAgcmV0dXJuIG5hbWVzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBgJHtjdXJyfSgke2FjY30pYCk7XG59O1xuXG5jb25zdCBidWlsZENvbXBvbmVudENvbnRhaW5lciA9IChiYXNlID0gYnVpbGRCYXNlQ29udGFpbmVyKCkpID0+ICh7XG4gIC4uLmJhc2UsXG5cbiAgLyoqXG4gICAqIEV4dGVuZHMgYmFzZS5nZXQgdG8gYWRkIGEgZGlzcGxheU5hbWUgdG8gdGhlIHNlcnZpY2VcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gY29udGV4dFxuICAgKiBAcGFyYW0gYXJnc1xuICAgKiBAcmV0dXJucyB7WE1MfVxuICAgKi9cbiAgZ2V0KGtleSwgY29udGV4dCwgLi4uYXJncykge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBiYXNlLmdldC5jYWxsKHRoaXMsIGtleSwgY29udGV4dCwgLi4uYXJncyk7XG5cbiAgICBpZiAoc2VydmljZS5kaXNwbGF5TmFtZSAmJiBzZXJ2aWNlLmRpc3BsYXlOYW1lLm1hdGNoKC9cXF0kLykpIHtcbiAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSAoc2VydmljZS5kaXNwbGF5TmFtZSB8fCBzZXJ2aWNlLm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgIGNvbnN0IGNvbXBvbmVudEtleSA9IChjb250ZXh0KSA/IGBbJHtjb250ZXh0fV1gIDogJyc7XG4gICAgLy8gQHRvZG8gdGhpcyBjYXVzZXMgaW5jb3JyZWN0IGNvbnRleHQgdG8gZGlzcGxheSBpZiB0aGlzIHNlcnZpY2UgaXMgdXNlZCBpbiBkaWZmZXJlbnQgY29udGV4dHNcbiAgICBzZXJ2aWNlLmRpc3BsYXlOYW1lID0gYCR7Y29tcG9uZW50TmFtZX0ke2NvbXBvbmVudEtleX1gO1xuXG4gICAgcmV0dXJuIHNlcnZpY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjdXN0b21pc2UoKSBmdW5jdGlvbiBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJpb3JpdGllc1xuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAqL1xuICBjcmVhdGVUcmFuc2Zvcm1lcihuYW1lLCBwcmlvcml0aWVzKSB7XG4gICAgcmV0dXJuIChrZXksIHdyYXBwZXIsIGRpc3BsYXlOYW1lKSA9PiB7XG4gICAgICB0aGlzLmN1c3RvbWlzZSh7IG5hbWUsIC4uLnByaW9yaXRpZXMsIGRpc3BsYXlOYW1lIH0sIGtleSwgd3JhcHBlcik7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZhY3RvcnkgbWV0aG9kIGZvciBhIHNlcnZpY2UsIGluY29ycG9yYXRpbmcgYWxsIHRoZSBnaXZlbiBtaWRkbGV3YXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YXJyYXl9IG1pZGRsZXdhcmVNYXRjaGVzXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICovXG4gIGdldEZhY3Rvcnkoa2V5LCBtaWRkbGV3YXJlTWF0Y2hlcykge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBiYXNlLmdldEZhY3RvcnkuY2FsbCh0aGlzLCBrZXksIG1pZGRsZXdhcmVNYXRjaGVzKTtcbiAgICBjb25zdCBuYW1lcyA9IG1pZGRsZXdhcmVNYXRjaGVzLm1hcChtaWRkbGV3YXJlID0+IG1pZGRsZXdhcmUuZGlzcGxheU5hbWUgfHwgbWlkZGxld2FyZS5uYW1lKTtcbiAgICBmYWN0b3J5LmRpc3BsYXlOYW1lID0gY3JlYXRlRGlzcGxheU5hbWUodGhpcy5zZXJ2aWNlc1trZXldLCBuYW1lcyk7XG5cbiAgICByZXR1cm4gZmFjdG9yeTtcbiAgfSxcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkQ29tcG9uZW50Q29udGFpbmVyO1xuIiwiaW1wb3J0IGJ1aWxkQmFzZUNvbnRhaW5lciBmcm9tICcuL2J1aWxkQmFzZUNvbnRhaW5lcic7XG5pbXBvcnQgTWlkZGxld2FyZVJlZ2lzdHJ5IGZyb20gJy4vTWlkZGxld2FyZVJlZ2lzdHJ5JztcblxuY29uc3QgYnVpbGRSZWR1Y2VyQ29udGFpbmVyID0gKGJhc2UgPSBidWlsZEJhc2VDb250YWluZXIoKSkgPT4gKHtcbiAgLi4uYmFzZSxcblxuICAvKipcbiAgICogVGhlIHJlZHV4IHN0b3JlIHdoaWNoIHdpbGwgYmUgcHJvdmlkaW5nIHRoZSBnbG9iYWwgY29udGV4dCBmb3IgdGhlIHJlZHVjZXIgbWlkZGxld2FyZVxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbiAgc3RvcmU6IG51bGwsXG5cbiAgc2V0U3RvcmUoc3RvcmUpIHtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGNvbXBvc2UgYW4gZXhpc3RpbmcgY29tcG9uZW50XG4gICAqIHdpdGggbmV3IHByb3BlcnRpZXMuXG4gICAqIE5vdGU6IG92ZXJyaWRlcyBiYXNlLmN1c3RvbWlzZSBiZWNhdXNlIHJlZHVjZXJzIGRvIG5vdCBoYXZlIGNvbnRleHRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1ldGEgQW4gb2JqZWN0IG9mIG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVuY3kgdG8gY3VzdG9taXNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb21wb3NlIHRoZSBkZXBlbmRlbmN5LiBHZXRzIHBhc3NlZCB0aGVcbiAgICogIHByZXZpb3VzIHN0YXRlIG9mIGNvbXBvc2l0aW9uXG4gICAqL1xuICBjdXN0b21pc2UobWV0YSwga2V5LCBmYWN0b3J5KSB7XG4gICAgdGhpcy5pc1Byb3RlY3RlZCgpO1xuXG4gICAgbGV0IHJlZ2lzdHJ5ID0gdGhpcy5taWRkbGV3YXJlUmVnaXN0cmllc1trZXldO1xuICAgIGlmICghcmVnaXN0cnkpIHtcbiAgICAgIHJlZ2lzdHJ5ID0gbmV3IE1pZGRsZXdhcmVSZWdpc3RyeSgpO1xuICAgICAgdGhpcy5taWRkbGV3YXJlUmVnaXN0cmllcyA9IHtcbiAgICAgICAgLi4udGhpcy5taWRkbGV3YXJlUmVnaXN0cmllcyxcbiAgICAgICAgW2tleV06IHJlZ2lzdHJ5LFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5oYW5jZWRGYWN0b3J5ID0gKHNlcnZpY2UpID0+IHtcbiAgICAgIGNvbnN0IGdldFN0YXRlID0gdGhpcy5zdG9yZSAmJiB0aGlzLnN0b3JlLmdldFN0YXRlO1xuXG4gICAgICByZXR1cm4gZmFjdG9yeShzZXJ2aWNlKShnZXRTdGF0ZSk7XG4gICAgfTtcbiAgICByZWdpc3RyeS5hZGQoXG4gICAgICBtZXRhLFxuICAgICAgZW5oYW5jZWRGYWN0b3J5XG4gICAgKTtcbiAgfSxcblxuICBnZXRBbGwoKSB7XG4gICAgY29uc3QgbmV3RmFjdG9yaWVzID0gKHRoaXMuaW5pdGlhbGlzZWQpXG4gICAgICA/IE9iamVjdC5lbnRyaWVzKHRoaXMuZmFjdG9yaWVzKS5yZWR1Y2UoKHByZXYsIFtrZXksIGZhY3RvcnldKSA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBba2V5XTogZmFjdG9yeSgpLFxuICAgICAgfSksIHt9KVxuICAgICAgLy8gcmV0dXJuIHRoZSBzZXJ2aWNlcyByZWdpc3RlcmVkIGlmIHdlIGhhdmVuJ3QgaW5pdGlhbGlzZWQgeWV0LlxuICAgICAgOiBPYmplY3QuZW50cmllcyh0aGlzLnNlcnZpY2VzKS5yZWR1Y2UoKHByZXYsIFtrZXksIHNlcnZpY2VdKSA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBba2V5XTogc2VydmljZSxcbiAgICAgIH0pLCB7fSk7XG5cbiAgICByZXR1cm4gbmV3RmFjdG9yaWVzO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkUmVkdWNlckNvbnRhaW5lcjtcbiIsImltcG9ydCBidWlsZEluamVjdG9yQ29udGFpbmVyIGZyb20gJy4vYnVpbGRJbmplY3RvckNvbnRhaW5lcic7XG5pbXBvcnQgYnVpbGRDb21wb25lbnRDb250YWluZXIgZnJvbSAnLi9idWlsZENvbXBvbmVudENvbnRhaW5lcic7XG5pbXBvcnQgYnVpbGRSZWR1Y2VyQ29udGFpbmVyIGZyb20gJy4vYnVpbGRSZWR1Y2VyQ29udGFpbmVyJztcblxuY29uc3QgSW5qZWN0b3IgPSBidWlsZEluamVjdG9yQ29udGFpbmVyKCk7XG5cbkluamVjdG9yLnJlZ2lzdGVyKCdjb21wb25lbnQnLCBidWlsZENvbXBvbmVudENvbnRhaW5lcigpKTtcbkluamVjdG9yLnJlZ2lzdGVyKCdyZWR1Y2VyJywgYnVpbGRSZWR1Y2VyQ29udGFpbmVyKCkpO1xuXG5leHBvcnQgZGVmYXVsdCBJbmplY3RvcjtcbiIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5qZWN0b3I6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBjb250ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHZhbGlkYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbmplY3RvciBmcm9tICcuL0NvbnRhaW5lcic7XG5pbXBvcnQgaW5qZWN0b3JDb250ZXh0IGZyb20gJy4vaW5qZWN0b3JDb250ZXh0JztcblxuZnVuY3Rpb24gcHJvdmlkZUluamVjdG9yKEluamVjdGFibGUsIGluamVjdG9yQ29udGFpbmVyID0gSW5qZWN0b3IpIHtcbiAgY2xhc3MgSW5qZWN0b3JQcm92aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgY29uc3QgeyBjb21wb25lbnQgfSA9IGluamVjdG9yQ29udGFpbmVyO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmplY3Rvcjoge1xuICAgICAgICAgIGdldDogY29tcG9uZW50LmdldC5iaW5kKGNvbXBvbmVudCksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiA8SW5qZWN0YWJsZSB7Li4udGhpcy5wcm9wc30gLz47XG4gICAgfVxuICB9XG5cbiAgSW5qZWN0b3JQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IGluamVjdG9yQ29udGV4dDtcblxuICByZXR1cm4gSW5qZWN0b3JQcm92aWRlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJvdmlkZUluamVjdG9yO1xuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjb250ZXh0VHlwZSBmcm9tICcuL2luamVjdG9yQ29udGV4dCc7XG5cbmNvbnN0IHByb3ZpZGVDb250ZXh0ID0gKGNvbnRleHQpID0+IChDb250ZXh0dWFsQ29tcG9uZW50KSA9PiB7XG4gIGNsYXNzIENvbnRleHRQcm92aWRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5qZWN0b3I6IHtcbiAgICAgICAgICAuLi50aGlzLmNvbnRleHQuaW5qZWN0b3IsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIDxDb250ZXh0dWFsQ29tcG9uZW50IHsuLi50aGlzLnByb3BzfSAvPjtcbiAgICB9XG4gIH1cblxuICBDb250ZXh0UHJvdmlkZXIuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGU7XG5cbiAgQ29udGV4dFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gY29udGV4dFR5cGU7XG5cbiAgcmV0dXJuIENvbnRleHRQcm92aWRlcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb3ZpZGVDb250ZXh0O1xuIiwiaW1wb3J0IGluamVjdG9yQ29udGV4dCBmcm9tICcuL2luamVjdG9yQ29udGV4dCc7XG5cbmNvbnN0IHdpdGhJbmplY3RvciA9IChDb21wb25lbnQpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSB7XG4gICAgLi4uKENvbXBvbmVudC5jb250ZXh0VHlwZXMgfHwge30pLFxuICAgIC4uLmluamVjdG9yQ29udGV4dCxcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGB3aXRoSW5qZWN0b3IoXG4gICAgJHsoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKX1cbiAgKWA7XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhJbmplY3RvcjtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY29udGV4dFR5cGUgZnJvbSAnLi9pbmplY3RvckNvbnRleHQnO1xuXG5jb25zdCBkZWZhdWx0Q29udGV4dCA9IChwcm9wcywgaW5qZWN0b3JDb250ZXh0KSA9PiBpbmplY3RvckNvbnRleHQ7XG5cbi8qKlxuICogSW5qZWN0cyBkZXBlbmRlbmNlcyBmcm9tIHRoZSBJbmplY3RvciBhcyBuYW1lZCBwcm9wcyBpbnRvIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge0FycmF5fSBkZXBlbmRlbmNpZXMgQSBsaXN0IG9mIG5hbWVkIGRlcGVuZGVuY2llc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRGVwZW5kZW5jaWVzVG9Qcm9wcyBNYXBzIHRoZSBmZXRjaGVkIGRlcGVuZGVuY2llcyB0byBwcm9wbmFtZXMsIGUuZy5cbiAqICAgKFRleHRGaWVsZCwgRm9ybUFjdGlvbikgPT4geyBteVRleHQ6IFRleHRGaWVsZCwgbXlBY3Rpb246IEZvcm1BY3Rpb24gfVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0Q29udGV4dCBHZXRzIHRoZSBuYW1lIG9mIHRoZSBjb250ZXh0IHRvIHBhc3MgdG8gSW5qZWN0b3IuXG4gKiAgIEFjY2VwdHMgdGhlIGNvbXBvbmVudCdzIHByb3BzIGFzIGEgcGFyYW0uIChwcm9wcykgPT4gYFNvbWVDb250ZXh0LiR7cHJvcHMuaWRlbnRpZmllcn1gO1xuICovXG5jb25zdCBpbmplY3QgPSAoZGVwZW5kZW5jaWVzLCBtYXBEZXBlbmRlbmNpZXNUb1Byb3BzLCBnZXRDb250ZXh0ID0gZGVmYXVsdENvbnRleHQpID0+IChcbiAgKEluamVjdGluZ0NvbXBvbmVudCkgPT4ge1xuICAgIGlmIChkZXBlbmRlbmNpZXMgJiYgIUFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIHdpdGhJbmplY3RvcigpIHBhc3NlZCBhbiBhcmd1bWVudCBmb3IgZGVwZW5kZW5jaWVzIHRoYXQgaXMgJHt0eXBlb2YgZGVwc30uIFxuICAgICAgTXVzdCBiZSBhbiBhcnJheSBvZiBuYW1lZCBkZXBlbmRlbmNpZXMuXG4gICAgYCk7XG4gICAgfVxuXG4gICAgaWYgKG1hcERlcGVuZGVuY2llc1RvUHJvcHMgJiYgdHlwZW9mIG1hcERlcGVuZGVuY2llc1RvUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBTZWNvbmQgcGFyYW1ldGVyIG9mIGluamVjdCgpIFttYXBEZXBlbmRlbmNpZXNUb1Byb3BzXSBtdXN0IGJlIGEgZnVuY3Rpb24sIHRha2luZyB0aGUgcmVzb2x2ZWRcbiAgICAgIGRlcGVuZGVuY2llcyBhcyBlbnVtZXJhdGVkIGFyZ3VtZW50cywgYW5kIHJldHVybmluZyBhIG1hcCBvZiBwcm9wIG5hbWVzIHRvIGRlcGVuZGVuY2llcy5cbiAgICBgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdldENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBUaGlyZCBwYXJhbWV0ZXIgb2YgaW5qZWN0KCkgW2dldENvbnRleHRdIG11c3QgYmUgYSBmdW5jdGlvbiwgdGFraW5nIHRoZSBjb21wb25lbnQncyBwcm9wc1xuICAgICAgYW5kIGN1cnJlbnQgaW5qZWN0IGNvbnRleHQgYXMgcGFyYW1ldGVycywgYW5kIHJldHVybmluZyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIEluamVjdG9yXG4gICAgICBjb250ZXh0IHRvIHVzZSB0aHJvdWdob3V0IHRoZSBjb21wb25lbnQuXG4gICAgYCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb25cbiAgICBjbGFzcyBJbmplY3RvciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICBjb250ZXh0OiBnZXRDb250ZXh0KHByb3BzLCBjb250ZXh0LmluamVjdG9yLmNvbnRleHQpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5qZWN0b3I6IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29udGV4dC5pbmplY3RvcixcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuc3RhdGUuY29udGV4dCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IGdldENvbnRleHQobmV4dFByb3BzLCBuZXh0Q29udGV4dC5pbmplY3Rvci5jb250ZXh0KTtcblxuICAgICAgICBpZiAobmV3Q29udGV4dCAhPT0gdGhpcy5zdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb250ZXh0OiBuZXdDb250ZXh0LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHByb3BzID0ge307XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBjb25zdCB7IGdldCB9ID0gdGhpcy5jb250ZXh0LmluamVjdG9yO1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gZGVwZW5kZW5jaWVzLm1hcChkZXAgPT4gZ2V0KGRlcCwgdGhpcy5zdGF0ZS5jb250ZXh0KSk7XG5cbiAgICAgICAgICBpZiAobWFwRGVwZW5kZW5jaWVzVG9Qcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBtYXBEZXBlbmRlbmNpZXNUb1Byb3BzKC4uLnJlc29sdmVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbWFwcGluZyBmdW5jdGlvbiBpcyBnaXZlbiwgbWlycm9yIHRoZSBwcm9wIG5hbWVzIGFuZCBkZXBlbmRlbmN5IG5hbWVzXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaCgoZGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBwcm9wc1tkZXBdID0gcmVzb2x2ZWRbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFwcm9wcyB8fCB0eXBlb2YgcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgbWFwRGVwZWRlbmNpZXNUb1Byb3BzIHBhcmFtZXRlciBwYXNzZWQgdG8gaW5qZWN0KClcbiAgICAgICAgICAgIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHRoYXQgbWFwcyBwcm9wIG5hbWVzIHRvIGRlcGVuZGVuY2llc1xuICAgICAgICAgIGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gPEluamVjdGluZ0NvbXBvbmVudCB7Li4ubmV3UHJvcHN9IC8+O1xuICAgICAgfVxuICAgIH1cblxuICAgIEluamVjdG9yLmNvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlO1xuXG4gICAgSW5qZWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBjb250ZXh0VHlwZTtcblxuICAgIHJldHVybiBJbmplY3RvcjtcbiAgfVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5qZWN0O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgTm90Rm91bmRDb21wb25lbnQgPSAoeyBpdGVtTmFtZSwgbmFtZSwgdmFsdWUgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhpdGVtTmFtZSwgJ25vdC1mb3VuZC1jb21wb25lbnQnKX0+XG4gICAgPGRpdj5cbiAgICAgICAgRmFpbGVkIHRvIGxvYWQgY29tcG9uZW50IVxuICAgIDwvZGl2PlxuICAgIHsobmFtZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgPyA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9e25hbWV9IHZhbHVlPXt2YWx1ZX0gLz5cbiAgICAgIDogbnVsbFxuICAgIH1cbiAgPC9kaXY+XG4pO1xuXG5Ob3RGb3VuZENvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIGl0ZW1OYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm90Rm91bmRDb21wb25lbnQ7XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHByb3ZpZGVJbmplY3RvciBmcm9tICcuL3Byb3ZpZGVJbmplY3Rvcic7XG5pbXBvcnQgd2l0aEluamVjdG9yIGZyb20gJy4vd2l0aEluamVjdG9yJztcbmltcG9ydCBJbmplY3RvciBmcm9tICcuL0NvbnRhaW5lcic7XG5pbXBvcnQgTm90Rm91bmRDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9Ob3RGb3VuZENvbXBvbmVudC9Ob3RGb3VuZENvbXBvbmVudCc7XG5pbXBvcnQgY29udGV4dFR5cGUgZnJvbSAnLi9pbmplY3RvckNvbnRleHQnO1xuXG4vKipcbiAqIEhhbmRsZXMgbG9hZGluZyBTaWx2ZXJTdHJpcGUtY2VudHJpYyBwcm92aWRlcnNcbiAqIFRoZXNlIG9wdGlvbnMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGEgY29udGV4dCBvYmplY3RcbiAqXG4gKiBFbnN1cmVzIHRoYXQgSW5qZWN0b3IgaXMgcmVhZHkgYmVmb3JlIHRoZSBwcm92aWRlZCBjb21wb25lbnQgd2lsbCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0TmFtZVxuICogQHBhcmFtIGNvbnRleHQgLSBwcm9wZXJ0aWVzIGluY2x1ZGUgdGhlIGZvbGxvd2luZ1xuICogICAgLSBzdG9yZSBmb3IgdGhlIHJlZHV4IHN0b3JlXG4gKiAgICAtIGFwb2xsb0NsaWVudCBmb3IgdGhlIGFwb2xsbyBjbGllbnQgKGdyYXBocWwpXG4gKiAgICAtIGNvbnRleHQgZm9yIGZpbHRlcmluZy9hcHBseWluZyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIG9idGFpbmVkIGNvbXBvbmVudFxuICogQHBhcmFtIG92ZXJyaWRlSW5qZWN0b3JcbiAqL1xuY29uc3QgbG9hZENvbXBvbmVudCA9ICh0YXJnZXROYW1lLCBjb250ZXh0ID0ge30sIG92ZXJyaWRlSW5qZWN0b3IpID0+IHtcbiAgY2xhc3MgTGVnYWN5TG9hZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgY29uc3QgaW5qZWN0b3JDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0LmNvbnRleHQ7XG4gICAgICBpZiAoIWluamVjdG9yQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5qZWN0b3I6IHtcbiAgICAgICAgICAuLi50aGlzLmNvbnRleHQuaW5qZWN0b3IsXG4gICAgICAgICAgY29udGV4dDogaW5qZWN0b3JDb250ZXh0LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBJbmplY3Rvci5yZWFkeSgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZXQgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGxldCB0YXJnZXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNvbnRleHQuaW5qZWN0b3IuZ2V0KHRhcmdldE5hbWUsIGNvbnRleHQgJiYgY29udGV4dC5jb250ZXh0KTtcbiAgICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRhcmdldCwgZXJyb3IgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlLXRocm93IHRoZSBlcnJvciwgYXMgd2UgZG8gbm90IHdhbnQgdG8gc2lsZW5jZSBpdCBpbiB0aGUgY29uc29sZVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgdGFyZ2V0LCBlcnJvciB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdGFyZ2V0OiB0YXJnZXROYW1lIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgVGFyZ2V0ID0gdGhpcy5zdGF0ZS50YXJnZXQ7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICBsZXQgTm90Rm91bmQgPSBOb3RGb3VuZENvbXBvbmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBOb3RGb3VuZCA9IHRoaXMuY29udGV4dC5pbmplY3Rvci5nZXQoJ05vdEZvdW5kQ29tcG9uZW50Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBjYW4ndCB0aHJvdyBhbmQgcmV0dXJuLi4uIHRvZ2V0aGVyLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiA8Tm90Rm91bmQgey4uLnRoaXMucHJvcHN9IGl0ZW1OYW1lPXt0YXJnZXROYW1lfSAvPjtcbiAgICAgIH1cblxuICAgICAgaWYgKFRhcmdldCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRhcmdldCB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIExlZ2FjeUxvYWRlci5jaGlsZENvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlO1xuXG4gIGNvbnN0IGNvbnRleHRJbmplY3RvciA9IG92ZXJyaWRlSW5qZWN0b3IgfHwgcHJvdmlkZUluamVjdG9yO1xuXG4gIHJldHVybiBjb250ZXh0SW5qZWN0b3Iod2l0aEluamVjdG9yKExlZ2FjeUxvYWRlcikpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbG9hZENvbXBvbmVudDtcbiIsImltcG9ydCBwcm92aWRlSW5qZWN0b3IgZnJvbSAnLi9kZXBlbmRlbmN5LWluamVjdGlvbi9wcm92aWRlSW5qZWN0b3InO1xuaW1wb3J0IHByb3ZpZGVDb250ZXh0IGZyb20gJy4vZGVwZW5kZW5jeS1pbmplY3Rpb24vcHJvdmlkZUNvbnRleHQnO1xuaW1wb3J0IHdpdGhJbmplY3RvciBmcm9tICcuL2RlcGVuZGVuY3ktaW5qZWN0aW9uL3dpdGhJbmplY3Rvcic7XG5pbXBvcnQgaW5qZWN0IGZyb20gJy4vZGVwZW5kZW5jeS1pbmplY3Rpb24vaW5qZWN0JztcbmltcG9ydCBsb2FkQ29tcG9uZW50IGZyb20gJy4vZGVwZW5kZW5jeS1pbmplY3Rpb24vbG9hZENvbXBvbmVudCc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vZGVwZW5kZW5jeS1pbmplY3Rpb24vQ29udGFpbmVyJztcblxuZXhwb3J0IHtcbiAgcHJvdmlkZUluamVjdG9yLFxuICBwcm92aWRlQ29udGV4dCxcbiAgd2l0aEluamVjdG9yLFxuICBpbmplY3QsXG4gIGxvYWRDb21wb25lbnQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n')}])}});